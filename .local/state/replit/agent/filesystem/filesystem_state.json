{"file_contents":{"app/data_sources/nfl.py":{"content":"from typing import List, Dict, Any\nfrom datetime import datetime, timedelta, timezone\n\nfrom app.config import MAX_EVENT_DAYS_AHEAD, EXCLUDE_TBA_STRINGS, CONFIRMED_EVENT_STATUSES\nfrom app.data_sources.nfl_stats import (\n    get_player_stats_espn,\n    get_team_stats_espn,\n    get_player_prop_probability_nfl,\n    get_nfl_leaders\n)\n\ndef is_confirmed_game(home_team: str, away_team: str, game_date: str = None) -> bool:\n    if not home_team or not away_team:\n        return False\n    \n    home_lower = home_team.lower()\n    away_lower = away_team.lower()\n    \n    for keyword in EXCLUDE_TBA_STRINGS:\n        if keyword.lower() in home_lower or keyword.lower() in away_lower:\n            return False\n    \n    if game_date:\n        try:\n            if isinstance(game_date, str):\n                if \"T\" in game_date:\n                    game_time = datetime.fromisoformat(game_date.replace(\"Z\", \"+00:00\"))\n                else:\n                    game_time = datetime.strptime(game_date, \"%Y-%m-%d\").replace(tzinfo=timezone.utc)\n            else:\n                game_time = game_date\n            \n            now = datetime.now(timezone.utc)\n            max_date = now + timedelta(days=MAX_EVENT_DAYS_AHEAD)\n            \n            if game_time < now or game_time > max_date:\n                return False\n        except Exception as e:\n            print(f\"Error parsing NFL game date: {e}\")\n            return False\n    \n    return True\n\ndef get_confirmed_upcoming_events_for_week(max_days_ahead: int = None) -> List[Dict[str, Any]]:\n    return []\n\ndef get_upcoming_games() -> List[Dict[str, Any]]:\n    return get_confirmed_upcoming_events_for_week()\n\ndef get_team_stats(team_name: str) -> Dict[str, Any]:\n    real_stats = get_team_stats_espn(team_name)\n    \n    if real_stats.get(\"error\") or real_stats.get(\"source\") == \"none\":\n        return {\n            \"win_rate\": 0.5,\n            \"ppg\": 22.0,\n            \"defensive_rating\": 22.0,\n            \"source\": \"fallback\",\n            \"error\": real_stats.get(\"error\", \"No data available\")\n        }\n    \n    return {\n        \"win_rate\": real_stats.get(\"win_rate\", 0.5),\n        \"ppg\": real_stats.get(\"ppg\", 22.0),\n        \"defensive_rating\": real_stats.get(\"defensive_rating\", 22.0),\n        \"record\": real_stats.get(\"record\", \"0-0\"),\n        \"source\": real_stats.get(\"source\", \"espn_api\"),\n        \"team_id\": real_stats.get(\"team_id\")\n    }\n\ndef get_player_stats(player_name: str, last_n_games: int = 10) -> Dict[str, Any]:\n    return get_player_stats_espn(player_name, last_n_games)\n\ndef get_player_props_analysis(player_name: str, prop_type: str, line: float) -> Dict[str, Any]:\n    result = get_player_prop_probability_nfl(player_name, prop_type, line)\n    return result\n\ndef get_model_probability(home_team: str, away_team: str) -> Dict[str, float]:\n    home_stats = get_team_stats(home_team)\n    away_stats = get_team_stats(away_team)\n    \n    home_win_rate = home_stats.get(\"win_rate\", 0.5)\n    away_win_rate = away_stats.get(\"win_rate\", 0.5)\n    \n    home_advantage = 0.05\n    prob_home = home_win_rate + home_advantage\n    prob_away = away_win_rate\n    \n    total = prob_home + prob_away\n    if total > 0:\n        prob_home = prob_home / total\n        prob_away = prob_away / total\n    else:\n        prob_home = 0.55\n        prob_away = 0.45\n    \n    return {home_team: round(prob_home, 3), away_team: round(prob_away, 3)}\n\ndef get_league_leaders(stat_type: str = \"passing\", limit: int = 20) -> List[Dict[str, Any]]:\n    return get_nfl_leaders(stat_type, limit)\n\ndef check_stats_availability() -> Dict[str, Any]:\n    return {\n        \"espn_api_available\": True,\n        \"source\": \"espn_api\"\n    }\n","path":null,"size_bytes":3654,"size_tokens":null},"app/services/multi_builder.py":{"content":"from typing import List, Dict, Any\nfrom app.services.analyzer import get_all_value_bets, get_high_confidence_bets\nfrom app.config import SETTINGS\n\ndef calculate_multi_odds(legs: List[Dict[str, Any]]) -> float:\n    if not legs:\n        return 1.0\n    combined = 1.0\n    for leg in legs:\n        combined *= leg[\"decimal_odds\"]\n    return round(combined, 2)\n\ndef build_suggested_multi(target_odds: float = None, max_legs: int = None) -> Dict[str, Any]:\n    if target_odds is None:\n        target_odds = SETTINGS[\"target_multi_odds\"]\n    if max_legs is None:\n        max_legs = SETTINGS[\"max_legs_in_multi\"]\n    \n    value_bets = get_all_value_bets()\n    \n    if not value_bets:\n        return {\n            \"legs\": [],\n            \"combined_odds\": 1.0,\n            \"combined_probability\": 0.0,\n            \"num_legs\": 0,\n            \"target_odds\": target_odds,\n            \"potential_return\": 0.0,\n        }\n    \n    min_legs = 2\n    selected_legs = []\n    current_odds = 1.0\n    used_events = set()\n    \n    min_target = target_odds * 0.85\n    max_target = target_odds * 1.5\n    \n    low_odds_bets = [b for b in value_bets if b[\"decimal_odds\"] <= 1.6]\n    other_bets = [b for b in value_bets if b[\"decimal_odds\"] > 1.6]\n    \n    sorted_bets = low_odds_bets + other_bets\n    \n    for bet in sorted_bets:\n        if len(selected_legs) >= max_legs:\n            break\n            \n        if bet[\"event\"] in used_events:\n            continue\n        \n        potential_odds = current_odds * bet[\"decimal_odds\"]\n        \n        if potential_odds <= max_target:\n            selected_legs.append(bet)\n            current_odds = potential_odds\n            used_events.add(bet[\"event\"])\n            \n            if len(selected_legs) >= min_legs and current_odds >= min_target:\n                break\n    \n    if len(selected_legs) < min_legs and len(selected_legs) < max_legs:\n        for bet in value_bets:\n            if bet[\"event\"] in used_events:\n                continue\n            \n            selected_legs.append(bet)\n            current_odds *= bet[\"decimal_odds\"]\n            used_events.add(bet[\"event\"])\n            \n            if len(selected_legs) >= min_legs or len(selected_legs) >= max_legs:\n                break\n    \n    combined_probability = 1.0\n    for leg in selected_legs:\n        combined_probability *= (leg[\"model_probability\"] / 100)\n    \n    return {\n        \"legs\": selected_legs,\n        \"combined_odds\": calculate_multi_odds(selected_legs),\n        \"combined_probability\": round(combined_probability * 100, 2),\n        \"num_legs\": len(selected_legs),\n        \"target_odds\": target_odds,\n        \"potential_return\": round(10 * calculate_multi_odds(selected_legs), 2),\n    }\n\ndef build_multiple_multis(count: int = 3, target_odds: float = None) -> List[Dict[str, Any]]:\n    if target_odds is None:\n        target_odds = SETTINGS[\"target_multi_odds\"]\n    \n    value_bets = get_all_value_bets()\n    multis = []\n    \n    main_multi = build_suggested_multi(target_odds)\n    if main_multi[\"legs\"]:\n        multis.append(main_multi)\n    \n    return multis\n","path":null,"size_bytes":3074,"size_tokens":null},"app/models/__init__.py":{"content":"","path":null,"size_bytes":0,"size_tokens":null},"app/main.py":{"content":"from fastapi import FastAPI\nfrom fastapi.staticfiles import StaticFiles\nfrom fastapi.responses import FileResponse\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom typing import Optional\nfrom datetime import datetime\nimport os\n\nfrom app.services.analyzer import (\n    get_all_value_bets, \n    get_value_bets_by_sport, \n    get_recommended_legs_for_week,\n    get_weekly_summary\n)\nfrom app.services.multi_builder import build_suggested_multi\nfrom app.config import SUPPORTED_SPORTS, SETTINGS\nfrom app.data_sources.odds_api import get_cache_stats, clear_cache\nfrom app.scheduled_fetch import fetch_and_store_all_odds, load_stored_data, is_fetch_day\nfrom app.db import init_db\nfrom app.models.probability import initialize_model\n\napp = FastAPI(\n    title=\"Sports Betting Analysis Engine\",\n    description=\"A backend service for analyzing sports betting value opportunities with ML-powered predictions, two-stage filtering, and data-backed rationales\",\n    version=\"3.0.0\"\n)\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n@app.on_event(\"startup\")\nasync def startup_event():\n    init_db()\n    initialize_model()\n    print(\"Database initialized and ML model loaded\")\n\n@app.get(\"/\")\nasync def health_check():\n    return {\n        \"status\": \"healthy\",\n        \"service\": \"Sports Betting Analysis Engine\",\n        \"version\": \"3.0.0\",\n        \"supported_sports\": SUPPORTED_SPORTS,\n        \"settings\": {\n            \"min_odds_filter\": SETTINGS[\"min_odds_filter\"],\n            \"max_odds_filter\": SETTINGS[\"max_odds_filter\"],\n            \"recommended_legs_count\": SETTINGS[\"recommended_legs_count\"],\n        }\n    }\n\n@app.get(\"/value-bets\")\nasync def get_value_bets(sport: Optional[str] = None, limit: Optional[int] = None):\n    try:\n        if sport:\n            bets = get_value_bets_by_sport(sport)\n        else:\n            bets = get_all_value_bets()\n        \n        if limit:\n            bets = bets[:limit]\n        \n        return {\n            \"success\": True,\n            \"count\": len(bets),\n            \"last_updated\": datetime.utcnow().isoformat(),\n            \"value_bets\": bets\n        }\n    except Exception as e:\n        return {\n            \"success\": False,\n            \"error\": str(e),\n            \"count\": 0,\n            \"value_bets\": []\n        }\n\n@app.get(\"/recommended-legs\")\nasync def get_recommended_legs(limit: int = 20):\n    try:\n        legs = get_recommended_legs_for_week(limit=limit)\n        \n        return {\n            \"success\": True,\n            \"count\": len(legs),\n            \"target_odds_range\": f\"{SETTINGS['min_odds_filter']:.2f} - {SETTINGS['max_odds_filter']:.2f}\",\n            \"last_updated\": datetime.utcnow().isoformat(),\n            \"recommended_legs\": legs\n        }\n    except Exception as e:\n        return {\n            \"success\": False,\n            \"error\": str(e),\n            \"count\": 0,\n            \"recommended_legs\": []\n        }\n\n@app.get(\"/weekly-summary\")\nasync def get_weekly_summary_endpoint():\n    try:\n        summary = get_weekly_summary()\n        summary[\"last_updated\"] = datetime.utcnow().isoformat()\n        return {\n            \"success\": True,\n            **summary\n        }\n    except Exception as e:\n        return {\n            \"success\": False,\n            \"error\": str(e)\n        }\n\n@app.get(\"/suggested-multi\")\nasync def get_suggested_multi(target_odds: float = 2.0, max_legs: int = 4):\n    try:\n        multi = build_suggested_multi(target_odds=target_odds, max_legs=max_legs)\n        return {\n            \"success\": True,\n            \"suggested_multi\": multi\n        }\n    except Exception as e:\n        return {\n            \"success\": False,\n            \"error\": str(e)\n        }\n\n@app.get(\"/sports\")\nasync def get_sports():\n    return {\n        \"success\": True,\n        \"sports\": SUPPORTED_SPORTS\n    }\n\n@app.get(\"/settings\")\nasync def get_settings():\n    return {\n        \"success\": True,\n        \"settings\": SETTINGS\n    }\n\n@app.get(\"/cache-stats\")\nasync def cache_stats():\n    stats = get_cache_stats()\n    return {\n        \"success\": True,\n        \"cache\": stats,\n        \"ttl_minutes\": stats[\"ttl_seconds\"] / 60,\n        \"description\": \"Cache reduces API calls. Data refreshes every 10 minutes.\"\n    }\n\n@app.post(\"/clear-cache\")\nasync def clear_cache_endpoint():\n    clear_cache()\n    return {\n        \"success\": True,\n        \"message\": \"Cache cleared. Next request will fetch fresh data from API.\"\n    }\n\n@app.post(\"/fetch-odds\")\nasync def fetch_odds_endpoint():\n    try:\n        data = fetch_and_store_all_odds()\n        total_markets = sum(\n            s.get(\"h2h_count\", 0) + s.get(\"props_count\", 0) \n            for s in data.get(\"sports\", {}).values()\n        )\n        return {\n            \"success\": True,\n            \"message\": f\"Fetched and stored {total_markets} markets\",\n            \"fetch_time\": data.get(\"fetch_time\"),\n            \"sports\": {k: {\"h2h\": v[\"h2h_count\"], \"props\": v[\"props_count\"]} \n                      for k, v in data.get(\"sports\", {}).items()}\n        }\n    except Exception as e:\n        return {\n            \"success\": False,\n            \"error\": str(e)\n        }\n\n@app.get(\"/stored-data-status\")\nasync def stored_data_status():\n    data = load_stored_data()\n    if data:\n        total_markets = sum(\n            s.get(\"h2h_count\", 0) + s.get(\"props_count\", 0) \n            for s in data.get(\"sports\", {}).values()\n        )\n        return {\n            \"success\": True,\n            \"has_stored_data\": True,\n            \"fetch_time\": data.get(\"fetch_time\"),\n            \"total_markets\": total_markets,\n            \"is_fetch_day\": is_fetch_day(),\n            \"fetch_days\": \"Monday and Thursday\"\n        }\n    return {\n        \"success\": True,\n        \"has_stored_data\": False,\n        \"is_fetch_day\": is_fetch_day(),\n        \"fetch_days\": \"Monday and Thursday\",\n        \"message\": \"No stored data. Run POST /fetch-odds to fetch.\"\n    }\n\nui_path = os.path.join(os.path.dirname(__file__), \"ui\")\napp.mount(\"/static\", StaticFiles(directory=ui_path), name=\"static\")\n\n@app.get(\"/ui\")\nasync def serve_ui():\n    return FileResponse(os.path.join(ui_path, \"index.html\"))\n\n@app.get(\"/value-picks\")\nasync def serve_value_picks():\n    return FileResponse(os.path.join(ui_path, \"value-picks.html\"))\n\n@app.get(\"/player-stats/{sport}/{player_name}\")\nasync def get_player_stats_endpoint(sport: str, player_name: str, games: int = 10):\n    try:\n        if sport.lower() == \"nba\":\n            from app.data_sources.nba import get_player_stats\n            stats = get_player_stats(player_name, last_n_games=games)\n        elif sport.lower() == \"nfl\":\n            from app.data_sources.nfl import get_player_stats\n            stats = get_player_stats(player_name, last_n_games=games)\n        else:\n            return {\"success\": False, \"error\": f\"Unsupported sport: {sport}\"}\n        \n        return {\n            \"success\": True,\n            \"sport\": sport,\n            \"player\": player_name,\n            \"stats\": stats\n        }\n    except Exception as e:\n        return {\"success\": False, \"error\": str(e)}\n\n@app.get(\"/team-stats/{sport}/{team_name}\")\nasync def get_team_stats_endpoint(sport: str, team_name: str):\n    try:\n        if sport.lower() == \"nba\":\n            from app.data_sources.nba import get_team_stats\n            stats = get_team_stats(team_name)\n        elif sport.lower() == \"nfl\":\n            from app.data_sources.nfl import get_team_stats\n            stats = get_team_stats(team_name)\n        else:\n            return {\"success\": False, \"error\": f\"Unsupported sport: {sport}\"}\n        \n        return {\n            \"success\": True,\n            \"sport\": sport,\n            \"team\": team_name,\n            \"stats\": stats\n        }\n    except Exception as e:\n        return {\"success\": False, \"error\": str(e)}\n\n@app.get(\"/stats-sources\")\nasync def get_stats_sources():\n    from app.data_sources.nba import check_stats_availability as nba_check\n    from app.data_sources.nfl import check_stats_availability as nfl_check\n    \n    return {\n        \"success\": True,\n        \"nba\": nba_check(),\n        \"nfl\": nfl_check(),\n        \"description\": \"Real-time stats from nba_api (NBA) and ESPN API (NFL)\"\n    }\n","path":null,"size_bytes":8219,"size_tokens":null},"app/db.py":{"content":"from sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker, declarative_base\nimport os\n\nSQLITE_URL = \"sqlite:///./betting_analysis.db\"\nDATABASE_URL = os.getenv(\"BETTING_DB_URL\", SQLITE_URL)\n\nif DATABASE_URL.startswith(\"postgresql\") and \"psycopg2\" not in DATABASE_URL:\n    try:\n        import psycopg2\n    except ImportError:\n        print(\"PostgreSQL driver not available, using SQLite instead\")\n        DATABASE_URL = SQLITE_URL\n\nif DATABASE_URL.startswith(\"sqlite\"):\n    engine = create_engine(DATABASE_URL, connect_args={\"check_same_thread\": False})\nelse:\n    try:\n        engine = create_engine(DATABASE_URL)\n    except Exception as e:\n        print(f\"Failed to connect to database: {e}, using SQLite\")\n        engine = create_engine(SQLITE_URL, connect_args={\"check_same_thread\": False})\n\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\ndef init_db():\n    from app import models_db\n    Base.metadata.create_all(bind=engine)\n","path":null,"size_bytes":1099,"size_tokens":null},"app/data_sources/__init__.py":{"content":"","path":null,"size_bytes":0,"size_tokens":null},"app/models/probability.py":{"content":"from typing import Dict, Any, Optional\nimport os\nimport joblib\nimport numpy as np\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.ensemble import GradientBoostingClassifier\nfrom app.config import MODEL_ARTIFACTS_PATH, SETTINGS\n\nmodel_cache = {}\n\ndef load_model(model_name: str = \"default\"):\n    global model_cache\n    \n    if model_name in model_cache:\n        return model_cache[model_name]\n    \n    model_path = os.path.join(MODEL_ARTIFACTS_PATH, f\"{model_name}_model.pkl\")\n    \n    if os.path.exists(model_path):\n        try:\n            model = joblib.load(model_path)\n            model_cache[model_name] = model\n            return model\n        except Exception as e:\n            print(f\"Error loading model {model_name}: {e}\")\n    \n    return None\n\ndef calculate_implied_probability(decimal_odds: float) -> float:\n    if decimal_odds <= 0:\n        return 0.0\n    return round(1 / decimal_odds, 4)\n\ndef calculate_fair_odds(probability: float) -> float:\n    if probability <= 0:\n        return float('inf')\n    return round(1 / probability, 2)\n\ndef extract_features(selection_name: str, sport: str, context: Optional[Dict] = None) -> np.ndarray:\n    context = context or {}\n    \n    features = []\n    \n    win_rate = context.get(\"win_rate\", 0.5)\n    recent_form = context.get(\"recent_form\", 0.5)\n    is_favorite = context.get(\"is_favorite\", False)\n    is_home = context.get(\"is_home\", False)\n    ranking_diff = context.get(\"ranking_diff\", 0)\n    implied_prob = context.get(\"implied_prob\", 0.5)\n    \n    features.append(win_rate)\n    features.append(recent_form)\n    features.append(1.0 if is_favorite else 0.0)\n    features.append(1.0 if is_home else 0.0)\n    features.append(ranking_diff / 100.0)\n    features.append(implied_prob)\n    \n    return np.array(features).reshape(1, -1)\n\ndef get_model_prediction(selection_name: str, sport: str, context: Optional[Dict] = None) -> float:\n    model = load_model(\"default\")\n    \n    if model is not None and context:\n        try:\n            features = extract_features(selection_name, sport, context)\n            prob = model.predict_proba(features)[0][1]\n            return float(round(prob, 4))\n        except Exception as e:\n            print(f\"Model prediction error: {e}\")\n    \n    return get_heuristic_probability(selection_name, sport, context)\n\ndef get_heuristic_probability(selection_name: str, sport: str, context: Optional[Dict] = None) -> float:\n    context = context or {}\n    \n    implied_prob = context.get(\"implied_prob\", 0.5)\n    is_favorite = context.get(\"is_favorite\", implied_prob > 0.5)\n    win_rate = context.get(\"win_rate\", 0.55 if is_favorite else 0.45)\n    recent_form = context.get(\"recent_form\", 0.55 if is_favorite else 0.45)\n    is_home = context.get(\"is_home\", False)\n    \n    base_prob = implied_prob\n    \n    if implied_prob >= 0.85:\n        if win_rate >= 0.65:\n            adjustment = 0.05\n        elif win_rate >= 0.55:\n            adjustment = 0.03\n        else:\n            adjustment = 0.01\n    elif implied_prob >= 0.75:\n        if win_rate >= 0.60:\n            adjustment = 0.04\n        else:\n            adjustment = 0.02\n    elif implied_prob >= 0.60:\n        adjustment = 0.03\n    else:\n        adjustment = 0.02\n    \n    if is_home:\n        adjustment += 0.02\n    if recent_form > 0.6:\n        adjustment += 0.02\n    \n    base_prob = implied_prob + adjustment\n    \n    return min(0.98, max(0.02, round(base_prob, 4)))\n\ndef calculate_edge(model_prob: float, implied_prob: float) -> float:\n    return round(model_prob - implied_prob, 4)\n\ndef train_model(training_data: list, model_name: str = \"default\") -> bool:\n    if not training_data or len(training_data) < 10:\n        print(\"Insufficient training data\")\n        return False\n    \n    try:\n        X = []\n        y = []\n        \n        for record in training_data:\n            features = [\n                record.get(\"win_rate\", 0.5),\n                record.get(\"recent_form\", 0.5),\n                1.0 if record.get(\"is_favorite\", False) else 0.0,\n                1.0 if record.get(\"is_home\", False) else 0.0,\n                record.get(\"ranking_diff\", 0) / 100.0,\n                record.get(\"implied_prob\", 0.5),\n            ]\n            X.append(features)\n            y.append(1 if record.get(\"won\", False) else 0)\n        \n        X = np.array(X)\n        y = np.array(y)\n        \n        model = GradientBoostingClassifier(\n            n_estimators=100,\n            max_depth=3,\n            learning_rate=0.1,\n            random_state=42\n        )\n        model.fit(X, y)\n        \n        os.makedirs(MODEL_ARTIFACTS_PATH, exist_ok=True)\n        model_path = os.path.join(MODEL_ARTIFACTS_PATH, f\"{model_name}_model.pkl\")\n        joblib.dump(model, model_path)\n        \n        global model_cache\n        model_cache[model_name] = model\n        \n        print(f\"Model trained and saved: {model_path}\")\n        return True\n        \n    except Exception as e:\n        print(f\"Error training model: {e}\")\n        return False\n\ndef generate_synthetic_training_data(n_samples: int = 500) -> list:\n    np.random.seed(42)\n    training_data = []\n    \n    for _ in range(n_samples):\n        win_rate = np.random.uniform(0.3, 0.8)\n        recent_form = np.random.uniform(0.3, 0.8)\n        is_favorite = np.random.random() > 0.5\n        is_home = np.random.random() > 0.5\n        ranking_diff = np.random.randint(-50, 50)\n        implied_prob = np.random.uniform(0.3, 0.9)\n        \n        win_prob = (\n            0.3 * win_rate +\n            0.2 * recent_form +\n            0.15 * (1 if is_favorite else 0) +\n            0.1 * (1 if is_home else 0) +\n            0.15 * (1 - ranking_diff / 100) +\n            0.1 * implied_prob\n        )\n        win_prob = min(0.95, max(0.05, win_prob))\n        \n        won = np.random.random() < win_prob\n        \n        training_data.append({\n            \"win_rate\": win_rate,\n            \"recent_form\": recent_form,\n            \"is_favorite\": is_favorite,\n            \"is_home\": is_home,\n            \"ranking_diff\": ranking_diff,\n            \"implied_prob\": implied_prob,\n            \"won\": won,\n        })\n    \n    return training_data\n\ndef initialize_model():\n    model = load_model(\"default\")\n    if model is None:\n        print(\"No trained model found. Training with synthetic data...\")\n        training_data = generate_synthetic_training_data(500)\n        train_model(training_data, \"default\")\n","path":null,"size_bytes":6397,"size_tokens":null},"app/data_sources/tennis.py":{"content":"from typing import List, Dict, Any\n\ndef get_upcoming_matches() -> List[Dict[str, Any]]:\n    return [\n        {\n            \"match_id\": \"tennis_001\",\n            \"player_a\": \"Carlos Alcaraz\",\n            \"player_b\": \"Jannik Sinner\",\n            \"tournament\": \"Australian Open\",\n            \"surface\": \"Hard\",\n            \"date\": \"2024-01-28\",\n        },\n        {\n            \"match_id\": \"tennis_002\",\n            \"player_a\": \"Novak Djokovic\",\n            \"player_b\": \"Daniil Medvedev\",\n            \"tournament\": \"Australian Open\",\n            \"surface\": \"Hard\",\n            \"date\": \"2024-01-28\",\n        },\n    ]\n\ndef get_player_stats(player_name: str) -> Dict[str, Any]:\n    mock_stats = {\n        \"Carlos Alcaraz\": {\"ranking\": 2, \"win_rate\": 0.85, \"hard_court_rate\": 0.82},\n        \"Jannik Sinner\": {\"ranking\": 4, \"win_rate\": 0.80, \"hard_court_rate\": 0.78},\n        \"Novak Djokovic\": {\"ranking\": 1, \"win_rate\": 0.88, \"hard_court_rate\": 0.90},\n        \"Daniil Medvedev\": {\"ranking\": 3, \"win_rate\": 0.78, \"hard_court_rate\": 0.82},\n    }\n    return mock_stats.get(player_name, {\"ranking\": 100, \"win_rate\": 0.5, \"hard_court_rate\": 0.5})\n\ndef get_model_probability(player_a: str, player_b: str) -> Dict[str, float]:\n    stats_a = get_player_stats(player_a)\n    stats_b = get_player_stats(player_b)\n    \n    prob_a = stats_a[\"win_rate\"] / (stats_a[\"win_rate\"] + stats_b[\"win_rate\"])\n    prob_b = 1 - prob_a\n    \n    return {player_a: round(prob_a, 3), player_b: round(prob_b, 3)}\n","path":null,"size_bytes":1476,"size_tokens":null},"app/utils.py":{"content":"from typing import List, Dict, Any\nfrom datetime import datetime\n\ndef format_decimal_odds(odds: float) -> str:\n    return f\"${odds:.2f}\"\n\ndef calculate_combined_odds(legs: List[Dict[str, Any]]) -> float:\n    if not legs:\n        return 1.0\n    combined = 1.0\n    for leg in legs:\n        combined *= leg.get(\"decimal_odds\", 1.0)\n    return round(combined, 2)\n\ndef get_current_timestamp() -> str:\n    return datetime.now().isoformat()\n\ndef validate_odds(odds: float) -> bool:\n    return odds >= 1.0\n\ndef calculate_payout(stake: float, decimal_odds: float) -> float:\n    return round(stake * decimal_odds, 2)\n\ndef format_percentage(value: float) -> str:\n    return f\"{value * 100:.1f}%\"\n","path":null,"size_bytes":685,"size_tokens":null},"app/__init__.py":{"content":"","path":null,"size_bytes":0,"size_tokens":null},"app/data_sources/nba.py":{"content":"from typing import List, Dict, Any\nfrom datetime import datetime, timedelta, timezone\n\nfrom app.config import MAX_EVENT_DAYS_AHEAD, EXCLUDE_TBA_STRINGS, CONFIRMED_EVENT_STATUSES\nfrom app.data_sources.nba_stats import (\n    get_player_season_stats,\n    get_team_stats_real,\n    get_player_prop_probability,\n    NBA_API_AVAILABLE\n)\n\ndef is_confirmed_game(home_team: str, away_team: str, game_date: str = None) -> bool:\n    if not home_team or not away_team:\n        return False\n    \n    home_lower = home_team.lower()\n    away_lower = away_team.lower()\n    \n    for keyword in EXCLUDE_TBA_STRINGS:\n        if keyword.lower() in home_lower or keyword.lower() in away_lower:\n            return False\n    \n    if game_date:\n        try:\n            if isinstance(game_date, str):\n                if \"T\" in game_date:\n                    game_time = datetime.fromisoformat(game_date.replace(\"Z\", \"+00:00\"))\n                else:\n                    game_time = datetime.strptime(game_date, \"%Y-%m-%d\").replace(tzinfo=timezone.utc)\n            else:\n                game_time = game_date\n            \n            now = datetime.now(timezone.utc)\n            max_date = now + timedelta(days=MAX_EVENT_DAYS_AHEAD)\n            \n            if game_time < now or game_time > max_date:\n                return False\n        except Exception as e:\n            print(f\"Error parsing NBA game date: {e}\")\n            return False\n    \n    return True\n\ndef get_confirmed_upcoming_events_for_week(max_days_ahead: int = None) -> List[Dict[str, Any]]:\n    return []\n\ndef get_upcoming_games() -> List[Dict[str, Any]]:\n    return get_confirmed_upcoming_events_for_week()\n\ndef get_team_stats(team_name: str) -> Dict[str, Any]:\n    real_stats = get_team_stats_real(team_name, last_n_games=10)\n    \n    if real_stats.get(\"error\") or real_stats.get(\"source\") == \"none\":\n        return {\n            \"win_rate\": 0.5,\n            \"ppg\": 110.0,\n            \"defensive_rating\": 115.0,\n            \"last_10\": \"5-5\",\n            \"source\": \"fallback\",\n            \"error\": real_stats.get(\"error\", \"No data available\")\n        }\n    \n    return {\n        \"win_rate\": real_stats.get(\"win_rate\", 0.5),\n        \"ppg\": real_stats.get(\"ppg\", 110.0),\n        \"defensive_rating\": real_stats.get(\"opponent_ppg\", 115.0),\n        \"last_10\": real_stats.get(\"last_10_record\", \"5-5\"),\n        \"source\": real_stats.get(\"source\", \"nba_api\"),\n        \"games_analyzed\": real_stats.get(\"games_played\", 0)\n    }\n\ndef get_player_props_analysis(player_name: str, prop_type: str, line: float) -> Dict[str, Any]:\n    result = get_player_prop_probability(player_name, prop_type, line)\n    return result\n\ndef get_player_stats(player_name: str, last_n_games: int = 10) -> Dict[str, Any]:\n    return get_player_season_stats(player_name, last_n_games)\n\ndef get_model_probability(home_team: str, away_team: str) -> Dict[str, float]:\n    home_stats = get_team_stats(home_team)\n    away_stats = get_team_stats(away_team)\n    \n    home_win_rate = home_stats.get(\"win_rate\", 0.5)\n    away_win_rate = away_stats.get(\"win_rate\", 0.5)\n    \n    home_advantage = 0.03\n    prob_home = home_win_rate + home_advantage\n    prob_away = away_win_rate\n    \n    total = prob_home + prob_away\n    if total > 0:\n        prob_home = prob_home / total\n        prob_away = prob_away / total\n    else:\n        prob_home = 0.53\n        prob_away = 0.47\n    \n    return {home_team: round(prob_home, 3), away_team: round(prob_away, 3)}\n\ndef check_stats_availability() -> Dict[str, Any]:\n    return {\n        \"nba_api_available\": NBA_API_AVAILABLE,\n        \"source\": \"nba_api\" if NBA_API_AVAILABLE else \"none\"\n    }\n","path":null,"size_bytes":3627,"size_tokens":null},"app/models/expected_value.py":{"content":"from typing import Dict, Any, Optional\nfrom app.models.probability import calculate_implied_probability, get_model_prediction\nfrom app.config import SETTINGS\n\ndef calculate_ev(model_prob: float, decimal_odds: float) -> float:\n    ev = (model_prob * decimal_odds) - 1\n    return round(ev, 4)\n\ndef is_value_bet(model_prob: float, decimal_odds: float, min_ev: float = None) -> bool:\n    if min_ev is None:\n        min_ev = SETTINGS[\"min_ev_threshold\"]\n    ev = calculate_ev(model_prob, decimal_odds)\n    return ev >= min_ev\n\ndef is_high_confidence(model_prob: float, min_confidence: float = None) -> bool:\n    if min_confidence is None:\n        min_confidence = SETTINGS[\"min_confidence_threshold\"]\n    return model_prob >= min_confidence\n\ndef analyze_selection(\n    selection_name: str, \n    decimal_odds: float, \n    sport: str, \n    context: Optional[Dict] = None,\n    min_ev_threshold: float = None,\n    min_confidence_threshold: float = None\n) -> Dict[str, Any]:\n    if min_ev_threshold is None:\n        min_ev_threshold = SETTINGS[\"min_ev_threshold\"]\n    if min_confidence_threshold is None:\n        min_confidence_threshold = SETTINGS[\"min_confidence_threshold\"]\n    \n    implied_prob = calculate_implied_probability(decimal_odds)\n    \n    if context is None:\n        context = {}\n    context[\"implied_prob\"] = implied_prob\n    \n    model_prob = get_model_prediction(selection_name, sport, context)\n    ev = calculate_ev(model_prob, decimal_odds)\n    edge = model_prob - implied_prob\n    \n    if model_prob >= 0.85 and ev >= 0.05:\n        confidence = \"HIGH\"\n    elif model_prob >= 0.75 and ev >= 0.02:\n        confidence = \"MEDIUM\"\n    elif model_prob >= 0.65 and ev >= 0.01:\n        confidence = \"LOW\"\n    else:\n        confidence = \"NONE\"\n    \n    if ev >= 0.10:\n        value_rating = 5\n    elif ev >= 0.06:\n        value_rating = 4\n    elif ev >= 0.04:\n        value_rating = 3\n    elif ev >= 0.02:\n        value_rating = 2\n    else:\n        value_rating = 1\n    \n    is_value = ev >= min_ev_threshold\n    is_confident = model_prob >= min_confidence_threshold\n    qualifies = is_value and is_confident\n    \n    return {\n        \"selection\": selection_name,\n        \"sport\": sport,\n        \"decimal_odds\": decimal_odds,\n        \"implied_probability\": round(implied_prob * 100, 2),\n        \"model_probability\": round(model_prob * 100, 2),\n        \"expected_value\": round(ev * 100, 2),\n        \"edge\": round(edge * 100, 2),\n        \"confidence\": confidence,\n        \"value_rating\": value_rating,\n        \"is_value_bet\": is_value,\n        \"is_high_confidence\": is_confident,\n        \"qualifies_as_recommended\": qualifies,\n    }\n\ndef analyze_market(market: Dict[str, Any]) -> Dict[str, Any]:\n    selection_name = market.get(\"selection_name\", \"\")\n    decimal_odds = market.get(\"decimal_odds\", 1.0)\n    sport = market.get(\"sport\", \"\")\n    \n    is_home = market.get(\"home_team\", \"\") == selection_name\n    is_favorite = decimal_odds < 2.0\n    \n    if decimal_odds <= 1.15:\n        win_rate = 0.75\n        recent_form = 0.75\n    elif decimal_odds <= 1.25:\n        win_rate = 0.68\n        recent_form = 0.68\n    elif decimal_odds <= 1.50:\n        win_rate = 0.60\n        recent_form = 0.60\n    elif is_favorite:\n        win_rate = 0.55\n        recent_form = 0.55\n    else:\n        win_rate = 0.42\n        recent_form = 0.42\n    \n    context = {\n        \"is_home\": is_home,\n        \"is_favorite\": is_favorite,\n        \"win_rate\": win_rate,\n        \"recent_form\": recent_form,\n        \"ranking_diff\": -20 if decimal_odds < 1.5 else (-10 if is_favorite else 10),\n    }\n    \n    analysis = analyze_selection(\n        selection_name=selection_name,\n        decimal_odds=decimal_odds,\n        sport=sport,\n        context=context\n    )\n    \n    analysis[\"event\"] = market.get(\"event\", \"\")\n    analysis[\"event_id\"] = market.get(\"event_id\", \"\")\n    analysis[\"market_type\"] = market.get(\"market_type\", \"moneyline\")\n    analysis[\"bookmaker\"] = market.get(\"bookmaker\", \"\")\n    analysis[\"commence_time\"] = market.get(\"commence_time\", \"\")\n    analysis[\"home_team\"] = market.get(\"home_team\", \"\")\n    analysis[\"away_team\"] = market.get(\"away_team\", \"\")\n    analysis[\"line\"] = market.get(\"line\")\n    analysis[\"side\"] = market.get(\"side\")\n    analysis[\"is_prop\"] = market.get(\"is_prop\", False)\n    \n    return analysis\n","path":null,"size_bytes":4300,"size_tokens":null},"app/services/__init__.py":{"content":"","path":null,"size_bytes":0,"size_tokens":null},"app/models_db.py":{"content":"from sqlalchemy import Column, Integer, String, Float, DateTime, Boolean, ForeignKey, Text\nfrom sqlalchemy.orm import relationship\nfrom datetime import datetime\nfrom app.db import Base\n\nclass Event(Base):\n    __tablename__ = \"events\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    external_id = Column(String(255), unique=True, index=True)\n    sport = Column(String(50), index=True)\n    league = Column(String(100))\n    home_team = Column(String(255))\n    away_team = Column(String(255))\n    event_datetime = Column(DateTime, index=True)\n    completed = Column(Boolean, default=False)\n    home_score = Column(Integer, nullable=True)\n    away_score = Column(Integer, nullable=True)\n    winner = Column(String(255), nullable=True)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n    \n    markets = relationship(\"Market\", back_populates=\"event\")\n    outcomes = relationship(\"Outcome\", back_populates=\"event\")\n\nclass Market(Base):\n    __tablename__ = \"markets\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    event_id = Column(Integer, ForeignKey(\"events.id\"), index=True)\n    selection_name = Column(String(255))\n    market_type = Column(String(50))\n    bookmaker = Column(String(100))\n    decimal_odds = Column(Float)\n    captured_at = Column(DateTime, default=datetime.utcnow)\n    \n    event = relationship(\"Event\", back_populates=\"markets\")\n    predictions = relationship(\"ModelPrediction\", back_populates=\"market\")\n\nclass Outcome(Base):\n    __tablename__ = \"outcomes\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    event_id = Column(Integer, ForeignKey(\"events.id\"), index=True)\n    selection_name = Column(String(255))\n    result = Column(String(20))\n    created_at = Column(DateTime, default=datetime.utcnow)\n    \n    event = relationship(\"Event\", back_populates=\"outcomes\")\n\nclass ModelPrediction(Base):\n    __tablename__ = \"model_predictions\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    market_id = Column(Integer, ForeignKey(\"markets.id\"), index=True)\n    model_name = Column(String(100))\n    predicted_probability = Column(Float)\n    ev = Column(Float)\n    is_high_confidence = Column(Boolean, default=False)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    \n    market = relationship(\"Market\", back_populates=\"predictions\")\n\nclass HistoricalData(Base):\n    __tablename__ = \"historical_data\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    sport = Column(String(50), index=True)\n    team_name = Column(String(255), index=True)\n    opponent = Column(String(255))\n    is_home = Column(Boolean)\n    team_score = Column(Integer)\n    opponent_score = Column(Integer)\n    won = Column(Boolean)\n    event_date = Column(DateTime, index=True)\n    season = Column(String(20))\n    \n    win_rate_last_10 = Column(Float, nullable=True)\n    avg_points_for = Column(Float, nullable=True)\n    avg_points_against = Column(Float, nullable=True)\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nclass TeamStats(Base):\n    __tablename__ = \"team_stats\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    sport = Column(String(50), index=True)\n    team_name = Column(String(255), index=True)\n    season = Column(String(20), index=True)\n    \n    total_wins = Column(Integer, default=0)\n    total_losses = Column(Integer, default=0)\n    win_rate = Column(Float, default=0.5)\n    home_wins = Column(Integer, default=0)\n    home_losses = Column(Integer, default=0)\n    away_wins = Column(Integer, default=0)\n    away_losses = Column(Integer, default=0)\n    \n    avg_points_for = Column(Float, default=0)\n    avg_points_against = Column(Float, default=0)\n    point_differential = Column(Float, default=0)\n    \n    last_5_wins = Column(Integer, default=0)\n    last_10_wins = Column(Integer, default=0)\n    current_streak = Column(Integer, default=0)\n    \n    ranking = Column(Integer, nullable=True)\n    strength_rating = Column(Float, default=50.0)\n    consistency_score = Column(Float, default=0.5)\n    \n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n\nclass RivalryTag(Base):\n    __tablename__ = \"rivalry_tags\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    sport = Column(String(50), index=True)\n    team1 = Column(String(255), index=True)\n    team2 = Column(String(255), index=True)\n    rivalry_name = Column(String(255))\n    rivalry_intensity = Column(Float, default=0.5)\n    \nclass DivisionalMatchup(Base):\n    __tablename__ = \"divisional_matchups\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    sport = Column(String(50), index=True)\n    division = Column(String(100))\n    team_name = Column(String(255), index=True)\n","path":null,"size_bytes":4795,"size_tokens":null},"replit.md":{"content":"# Sports Betting Analysis Engine\n\n## Overview\nA Python FastAPI backend service for analyzing sports betting value opportunities across UFC, NBA, NFL, and NRL. The system uses ML-powered Expected Value (EV) calculations with two-stage filtering to identify up to 20 high-confidence betting legs with odds between 1.05-1.25 for safe multi-leg parlays. Each recommendation includes a data-backed rationale explaining the pick based purely on probability analysis. Uses ONLY real live data from The Odds API with scheduled Monday/Thursday fetches.\n\n## Data Sources (All Real - No Mock Data)\n- **Odds Data**: The Odds API (Australian bookmakers)\n- **NBA Stats**: nba_api Python package (official NBA.com data)\n- **NFL Stats**: ESPN API (unofficial, free, no auth required)\n- **Cross-validation**: Multiple sources verify stats accuracy\n\n## Project Structure\n```\n/app\n    __init__.py\n    main.py              # FastAPI entry point\n    config.py            # Settings and configuration\n    utils.py             # Shared helper functions\n    db.py                # SQLite database configuration\n    models_db.py         # SQLAlchemy ORM models\n    scheduled_fetch.py   # Scheduled data fetching logic\n\n/app/data_sources\n    __init__.py\n    nba.py               # NBA game data (uses nba_stats.py)\n    nfl.py               # NFL game data (uses nfl_stats.py)\n    odds_api.py          # The Odds API integration\n    nba_stats.py         # Real NBA stats from nba_api\n    nfl_stats.py         # Real NFL stats from ESPN API\n\n/app/models\n    __init__.py\n    probability.py       # ML probability model (Random Forest)\n    expected_value.py    # EV calculation and bet analysis\n\n/app/services\n    __init__.py\n    analyzer.py          # Two-stage filtering with composite scoring\n    multi_builder.py     # Parlay builder targeting ~$2 odds\n\n/app/ui\n    index.html           # Main web interface (recommended legs)\n    value-picks.html     # Separate value picks page\n    script.js            # Frontend JavaScript\n    styles.css           # Styling\n\n/model_artifacts\n    default_model.pkl    # Trained ML model\n\ncached_odds_data.json    # Stored odds data from scheduled fetches\nfetch_scheduled.py       # Standalone fetch script for cron\n```\n\n## API Endpoints\n- `GET /` - Health check (version 3.0.0)\n- `GET /recommended-legs` - Get up to 20 high-confidence legs with rationales\n- `GET /weekly-summary` - Get weekly analysis summary\n- `GET /value-bets` - Get all value bets (?sport=nba&limit=100)\n- `GET /suggested-multi` - Get suggested parlay (?target_odds=2.0&max_legs=4)\n- `GET /sports` - List supported sports (ufc, nba, nfl, nrl)\n- `GET /settings` - View current configuration\n- `GET /cache-stats` - View cache statistics\n- `POST /clear-cache` - Manually clear cached data\n- `POST /fetch-odds` - Trigger immediate data fetch\n- `GET /stored-data-status` - Check when data was last fetched\n- `GET /ui` - Main web interface\n- `GET /value-picks` - Value picks page\n- `GET /stats-sources` - View connected stats APIs status\n- `GET /player-stats/{sport}/{player_name}` - Get real player statistics\n- `GET /team-stats/{sport}/{team_name}` - Get real team statistics\n\n## Stats API Endpoints\n\n### Player Stats\n```\nGET /player-stats/nfl/Patrick%20Mahomes\nGET /player-stats/nba/LeBron%20James?games=10\n```\nReturns real season stats, averages, and totals from ESPN (NFL) or NBA.com (NBA).\n\n### Team Stats\n```\nGET /team-stats/nfl/Kansas%20City%20Chiefs\nGET /team-stats/nba/Boston%20Celtics\n```\nReturns real win rates, PPG, defensive ratings from official sources.\n\n## Supported Sports\n- **NBA** - Basketball with extensive player props and alternates (real stats from nba_api)\n- **NFL** - Football with comprehensive player props and alternates (real stats from ESPN API)\n\n## Allowed Market Types by Sport\n\n### NFL Markets (16 markets)\n| Market Type | Description |\n|-------------|-------------|\n| `moneyline` | Game winner (head-to-head) |\n| `spread` | Point spread betting |\n| `totals` | Over/under total points |\n| `player_pass_tds_over_under` | QB passing touchdowns |\n| `player_pass_yards_over_under` | QB passing yards |\n| `player_pass_completions_over_under` | QB pass completions |\n| `player_pass_attempts_over_under` | QB pass attempts |\n| `player_rush_yards_over_under` | Player rushing yards |\n| `player_rush_attempts_over_under` | Player rush attempts |\n| `player_receiving_yards_over_under` | Player receiving yards |\n| `player_receptions_over_under` | Player total receptions |\n| `player_anytime_touchdown` | Player to score anytime |\n| `player_first_touchdown` | First touchdown scorer |\n| `alternate_player_pass_yards` | Alternate passing yards lines (250+, 300+, etc.) |\n| `alternate_player_rush_yards` | Alternate rushing yards lines (75+, 100+, etc.) |\n| `alternate_player_receiving_yards` | Alternate receiving yards lines (50+, 75+, etc.) |\n\n### NBA Markets (13 markets)\n| Market Type | Description |\n|-------------|-------------|\n| `moneyline` | Game winner (head-to-head) |\n| `player_points_over_under` | Player total points |\n| `player_assists_over_under` | Player total assists |\n| `player_rebounds_over_under` | Player total rebounds |\n| `player_threes_over_under` | Player three-pointers made |\n| `player_blocks_over_under` | Player total blocks |\n| `player_steals_over_under` | Player total steals |\n| `player_pra_over_under` | Points + Rebounds + Assists combo |\n| `player_double_double` | Player to get a double-double |\n| `alternate_player_points` | Alternate points lines (25+, 30+, 35+, etc.) |\n| `alternate_player_rebounds` | Alternate rebounds lines (10+, 12+, etc.) |\n| `alternate_player_assists` | Alternate assists lines (8+, 10+, etc.) |\n| `alternate_player_threes` | Alternate threes lines (4+, 5+, etc.) |\n\n## Alternate Lines Explained\nAlternate lines offer different thresholds than the standard line:\n- **Standard**: Patrick Mahomes Over/Under 275.5 passing yards\n- **Alternate**: Patrick Mahomes 300+ passing yards (higher odds, lower probability)\n\nThese are useful for finding value when statistics suggest a player will significantly exceed expectations.\n\n## Two-Stage Filtering Process\n\n### Stage 1: Numerical Filter (All markets -> ~60 candidates)\n- Odds between 1.05 and 1.25\n- Model probability >= 75%\n- Edge (model prob - implied prob) >= 2 percentage points\n- EV >= -5%\n\n### Stage 2: Deep Prune (60 candidates -> up to 20 final legs)\n- Composite score calculation\n- Rivalry/upset risk penalties\n- Consistency bonuses\n- Rank by score, select top 20\n\n## Key Formulas\n- **Implied Probability**: `1 / decimal_odds`\n- **Expected Value**: `(model_prob * decimal_odds) - 1`\n- **Edge**: `model_probability - implied_probability`\n- **Composite Score**: `(model_prob * 0.4) + (ev * 20 * 0.3) + (edge * 10 * 0.2) + (consistency * 100 * 0.1)`\n\n## Event Filtering\n- Only includes confirmed, scheduled matchups\n- Automatically excludes events that have already occurred\n- Only shows events within 7 days from current time\n- Excludes TBA/TBD matchups\n\n## Australian Bookmakers Supported\n- Sportsbet, TAB, Neds, Ladbrokes, Betfair, Unibet, Pointsbet, Betr\n\n## Environment Variables\n- `THE_ODDS_API_KEY` - API key for The Odds API (required for live data)\n- `BETTING_DB_URL` - Database URL (defaults to SQLite)\n\n## Running the Application\n```bash\nuvicorn app.main:app --host 0.0.0.0 --port 5000 --reload\n```\n\n## Scheduled Fetching\nThe system fetches fresh odds data only on Mondays and Thursdays to minimize API usage:\n- **Script**: `python fetch_scheduled.py`\n- **Schedule**: Mondays and Thursdays at 6:00 AM UTC\n- **Cron expression**: `0 6 * * 1,4`\n- **API usage**: ~4 requests per fetch, ~32/month total\n\n### Manual Fetch\n- `POST /fetch-odds` - Trigger immediate fetch\n- `GET /stored-data-status` - Check when data was last fetched\n\n## Deployment Notes\n- **Main API**: Uses autoscale deployment (stateless)\n- **Scheduled Task**: Runs `python fetch_scheduled.py` on Mon/Thu\n- Requires `THE_ODDS_API_KEY` secret for production\n- Free tier: 500 requests/month (system uses ~32)\n\n## Current State\n- Real odds from Australian bookmakers via The Odds API\n- Real NFL stats from ESPN API (no auth required)\n- Real NBA stats from nba_api (official NBA.com data)\n- NO mock/hardcoded data - all stats are live\n- Two-stage filtering with composite scoring\n- Data-backed rationales for each recommended leg (pure probability analysis)\n- Scheduled Mon/Thu fetches to optimize API usage\n- Card-based UI with expandable rationales\n- Separate value picks page with filtering\n- Supports alternate player prop lines for NFL/NBA\n- Automatic past event filtering\n\n## Recent Changes (Dec 11, 2025)\n- Integrated real NFL stats via ESPN API (free, no auth)\n- Integrated real NBA stats via nba_api package\n- Removed ALL mock/hardcoded data from codebase\n- Added /player-stats and /team-stats endpoints\n- Added /stats-sources endpoint to verify data sources\n- Increased recommended legs cap from 12 to 20\n- Removed Tennis as a supported sport\n- Added separate Value Picks page (/value-picks)\n- Added automatic filtering of past events\n\n## Stats Data Available\n\n### NFL Player Stats (from ESPN)\n- Passing: yards, TDs, completions, attempts, rating\n- Rushing: yards, attempts, TDs\n- Receiving: yards, receptions, TDs\n\n### NBA Player Stats (from nba_api)\n- Points, rebounds, assists\n- Threes made, steals, blocks\n- Game logs and hit rates\n\n### Team Stats\n- Win rate, PPG, defensive rating\n- Recent form (last 10 games)\n","path":null,"size_bytes":9409,"size_tokens":null},"app/services/analyzer.py":{"content":"from typing import List, Dict, Any, Optional\nimport os\nimport json\nfrom datetime import datetime, timedelta\nfrom app.data_sources.odds_api import get_upcoming_markets_for_week\nfrom app.models.expected_value import analyze_market\nfrom app.config import SETTINGS, MAX_EVENT_DAYS_AHEAD\n\nSTORED_DATA_FILE = \"cached_odds_data.json\"\n\ndef is_future_event(market: Dict[str, Any]) -> bool:\n    commence_time = market.get(\"commence_time\")\n    if not commence_time:\n        return False\n    try:\n        if isinstance(commence_time, str):\n            event_time = datetime.fromisoformat(commence_time.replace(\"Z\", \"+00:00\"))\n            now = datetime.now(event_time.tzinfo) if event_time.tzinfo else datetime.utcnow()\n            max_date = now + timedelta(days=MAX_EVENT_DAYS_AHEAD)\n            return now < event_time <= max_date\n    except Exception:\n        pass\n    return False\n\ndef load_stored_odds():\n    if os.path.exists(STORED_DATA_FILE):\n        try:\n            with open(STORED_DATA_FILE, \"r\") as f:\n                data = json.load(f)\n                all_markets = []\n                for sport, sport_data in data.get(\"sports\", {}).items():\n                    all_markets.extend(sport_data.get(\"h2h\", []))\n                    all_markets.extend(sport_data.get(\"props\", []))\n                future_markets = [m for m in all_markets if is_future_event(m)]\n                print(f\"Loaded {len(future_markets)} future events (filtered {len(all_markets) - len(future_markets)} past events)\")\n                return future_markets, data.get(\"fetch_time\")\n        except Exception:\n            pass\n    return None, None\n\nKNOWN_RIVALRIES = {\n    \"nfl\": [\n        (\"Dallas Cowboys\", \"Philadelphia Eagles\", \"NFC East Rivalry\"),\n        (\"Green Bay Packers\", \"Chicago Bears\", \"Oldest NFL Rivalry\"),\n        (\"New England Patriots\", \"New York Jets\", \"AFC East Rivalry\"),\n        (\"Kansas City Chiefs\", \"Las Vegas Raiders\", \"AFC West Rivalry\"),\n        (\"San Francisco 49ers\", \"Seattle Seahawks\", \"NFC West Rivalry\"),\n    ],\n    \"nba\": [\n        (\"Los Angeles Lakers\", \"Boston Celtics\", \"Historic NBA Rivalry\"),\n        (\"Los Angeles Lakers\", \"Los Angeles Clippers\", \"LA Battle\"),\n        (\"Golden State Warriors\", \"Cleveland Cavaliers\", \"Finals Rivalry\"),\n        (\"Miami Heat\", \"Boston Celtics\", \"Eastern Rivalry\"),\n    ],\n}\n\nTEAM_STATS_CACHE = {}\n\ndef derive_stats_from_odds(team_name: str, odds: float, is_favorite: bool) -> Dict[str, Any]:\n    implied_prob = 1 / odds if odds > 1 else 0.5\n    \n    if is_favorite and odds <= 1.25:\n        win_rate = min(0.65 + (1.25 - odds) * 2, 0.85)\n        wins_10 = int(win_rate * 10)\n        losses_10 = 10 - wins_10\n        point_diff = (1.25 - odds) * 50 + 3\n        consistency = 0.65 + implied_prob * 0.2\n        strength = 50 + implied_prob * 40\n        streak = max(1, int((1.25 - odds) * 10))\n    else:\n        win_rate = implied_prob * 0.9\n        wins_10 = int(win_rate * 10)\n        losses_10 = 10 - wins_10\n        point_diff = (implied_prob - 0.5) * 20\n        consistency = 0.4 + implied_prob * 0.3\n        strength = 30 + implied_prob * 35\n        streak = int((implied_prob - 0.5) * 4)\n    \n    return {\n        \"team_name\": team_name,\n        \"win_rate\": round(win_rate, 3),\n        \"last_10_record\": f\"{wins_10}-{losses_10}\",\n        \"last_5_record\": f\"{min(wins_10 // 2 + 1, 5)}-{max(0, 5 - wins_10 // 2 - 1)}\",\n        \"point_differential\": round(point_diff, 1),\n        \"consistency_score\": round(min(consistency, 0.95), 2),\n        \"strength_rating\": round(min(strength, 90), 1),\n        \"current_streak\": streak,\n    }\n\ndef get_team_stats(team_name: str, sport: str, odds: float = 1.15, is_favorite: bool = True) -> Dict[str, Any]:\n    cache_key = f\"{sport}_{team_name}_{odds}\"\n    if cache_key in TEAM_STATS_CACHE:\n        return TEAM_STATS_CACHE[cache_key]\n    \n    stats = derive_stats_from_odds(team_name, odds, is_favorite)\n    stats[\"sport\"] = sport\n    \n    TEAM_STATS_CACHE[cache_key] = stats\n    return stats\n\ndef check_rivalry(team1: str, team2: str, sport: str) -> Optional[Dict[str, Any]]:\n    rivalries = KNOWN_RIVALRIES.get(sport.lower(), [])\n    for t1, t2, name in rivalries:\n        if (t1 in team1 or team1 in t1) and (t2 in team2 or team2 in t2):\n            return {\"is_rivalry\": True, \"name\": name, \"intensity\": 0.7}\n        if (t2 in team1 or team1 in t2) and (t1 in team2 or team2 in t1):\n            return {\"is_rivalry\": True, \"name\": name, \"intensity\": 0.7}\n    return {\"is_rivalry\": False, \"name\": None, \"intensity\": 0}\n\ndef calculate_composite_score(market: Dict[str, Any], fav_stats: Dict, opp_stats: Dict, rivalry_info: Dict) -> float:\n    model_prob = market.get(\"model_probability\", 0) / 100\n    ev = market.get(\"expected_value\", 0) / 100\n    implied_prob = market.get(\"implied_probability\", 0) / 100\n    edge = model_prob - implied_prob\n    consistency = fav_stats.get(\"consistency_score\", 0.5)\n    \n    score = (model_prob * 0.4) + (ev * 20 * 0.3) + (edge * 10 * 0.2) + (consistency * 100 * 0.1)\n    \n    score = score * 100\n    \n    if rivalry_info.get(\"is_rivalry\", False):\n        score -= 8 * rivalry_info.get(\"intensity\", 0.5)\n    \n    if fav_stats.get(\"current_streak\", 0) >= 3:\n        score += 2\n    if opp_stats.get(\"current_streak\", 0) <= -2:\n        score += 2\n    \n    return round(score, 2)\n\ndef generate_rationale(market: Dict, fav_stats: Dict, opp_stats: Dict, rivalry_info: Dict) -> str:\n    selection = market.get(\"selection\", \"\")\n    sport = market.get(\"sport\", \"\").upper()\n    model_prob = market.get(\"model_probability\", 0)\n    implied_prob = market.get(\"implied_probability\", 0)\n    ev = market.get(\"expected_value\", 0)\n    odds = market.get(\"decimal_odds\", 1.0)\n    edge = model_prob - implied_prob\n    \n    parts = []\n    \n    fav_record = fav_stats.get(\"last_10_record\", \"7-3\")\n    fav_wins = int(fav_record.split(\"-\")[0]) if \"-\" in fav_record else 7\n    fav_diff = fav_stats.get(\"point_differential\", 0)\n    consistency = fav_stats.get(\"consistency_score\", 0) * 100\n    strength = fav_stats.get(\"strength_rating\", 50)\n    \n    parts.append(f\"MODEL ANALYSIS: {selection} ({sport}) @ ${odds:.2f}\")\n    \n    parts.append(f\"Form: {fav_wins} of last 10 wins, {fav_diff:+.1f} point differential, {consistency:.0f}% consistency rating.\")\n    \n    if opp_stats and opp_stats.get(\"win_rate\"):\n        opp_record = opp_stats.get(\"last_10_record\", \"N/A\")\n        opp_diff = opp_stats.get(\"point_differential\", 0)\n        opp_strength = opp_stats.get(\"strength_rating\", 50)\n        strength_gap = strength - opp_strength\n        parts.append(f\"Opponent form: {opp_record} last 10, {opp_diff:+.1f} differential. Strength gap: {strength_gap:+.1f} rating points.\")\n    \n    parts.append(f\"Edge: Model {model_prob:.1f}% vs market implied {implied_prob:.1f}% = {edge:.1f}pp edge. EV: {ev:+.1f}%.\")\n    \n    if rivalry_info.get(\"is_rivalry\", False):\n        parts.append(f\"RISK NOTE: {rivalry_info['name']} - rivalry games historically closer. Factored into score with -5.6 penalty.\")\n    \n    if odds <= 1.10:\n        parts.append(\"Market view: Heavy favorite (implied >90% win probability).\")\n    elif odds <= 1.15:\n        parts.append(\"Market view: Strong favorite (implied 85-90% win probability).\")\n    elif odds <= 1.20:\n        parts.append(\"Market view: Clear favorite (implied 80-85% win probability).\")\n    else:\n        parts.append(\"Market view: Moderate favorite (implied 75-80% win probability).\")\n    \n    parts.append(\"Note: This is model-based analysis, not a guarantee. Always bet responsibly.\")\n    \n    return \" \".join(parts)\n\ndef get_all_analyzed_markets() -> List[Dict[str, Any]]:\n    stored_markets, fetch_time = load_stored_odds()\n    if stored_markets and len(stored_markets) > 0:\n        print(f\"Using stored data from {fetch_time} ({len(stored_markets)} markets)\")\n        markets = stored_markets\n    else:\n        try:\n            markets = get_upcoming_markets_for_week()\n        except Exception as e:\n            print(f\"Error fetching live markets: {e}\")\n            markets = []\n    \n    analyzed = []\n    for market in markets:\n        try:\n            analysis = analyze_market(market)\n            analyzed.append(analysis)\n        except Exception as e:\n            print(f\"Error analyzing market {market}: {e}\")\n            continue\n    \n    return analyzed\n\ndef deduplicate_bets(bets: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n    seen = set()\n    unique_bets = []\n    \n    for bet in bets:\n        key = (\n            bet.get(\"event_id\", \"\") or f\"{bet.get('home_team', '')}_vs_{bet.get('away_team', '')}\",\n            bet.get(\"selection\", \"\"),\n            bet.get(\"market_type\", \"\"),\n            bet.get(\"point\", \"\")\n        )\n        \n        if key not in seen:\n            seen.add(key)\n            unique_bets.append(bet)\n    \n    return unique_bets\n\ndef get_all_value_bets() -> List[Dict[str, Any]]:\n    analyzed = get_all_analyzed_markets()\n    \n    value_bets = [m for m in analyzed if m.get(\"is_value_bet\", False)]\n    \n    value_bets = deduplicate_bets(value_bets)\n    \n    for bet in value_bets:\n        if not bet.get(\"rationale\"):\n            selection = bet.get(\"selection\", \"\")\n            sport = bet.get(\"sport\", \"\")\n            odds = bet.get(\"decimal_odds\", 1.5)\n            home_team = bet.get(\"home_team\", \"\")\n            away_team = bet.get(\"away_team\", \"\")\n            opponent = away_team if selection == home_team else home_team\n            opp_odds = 1 / (1 - (1 / odds)) if odds > 1 and odds < 5 else 3.0\n            \n            fav_stats = get_team_stats(selection, sport, odds=odds, is_favorite=(odds < 2.0))\n            opp_stats = get_team_stats(opponent, sport, odds=opp_odds, is_favorite=False) if opponent else {}\n            rivalry_info = check_rivalry(home_team, away_team, sport)\n            \n            bet[\"rationale\"] = generate_rationale(bet, fav_stats, opp_stats, rivalry_info)\n    \n    value_bets.sort(key=lambda x: x[\"expected_value\"], reverse=True)\n    \n    return value_bets\n\ndef get_value_bets_by_sport(sport: str) -> List[Dict[str, Any]]:\n    all_bets = get_all_value_bets()\n    return [bet for bet in all_bets if bet[\"sport\"].lower() == sport.lower()]\n\ndef get_top_value_bets(limit: int = 10) -> List[Dict[str, Any]]:\n    all_bets = get_all_value_bets()\n    return all_bets[:limit]\n\ndef get_high_confidence_bets() -> List[Dict[str, Any]]:\n    all_bets = get_all_value_bets()\n    return [bet for bet in all_bets if bet.get(\"is_high_confidence\", False)]\n\ndef stage1_numerical_filter(markets: List[Dict[str, Any]], min_odds: float = 1.05, max_odds: float = 1.25) -> List[Dict[str, Any]]:\n    candidates = []\n    \n    for market in markets:\n        odds = market.get(\"decimal_odds\", 0)\n        model_prob = market.get(\"model_probability\", 0)\n        implied_prob = market.get(\"implied_probability\", 0)\n        ev = market.get(\"expected_value\", 0)\n        \n        if not (min_odds <= odds <= max_odds):\n            continue\n        \n        if model_prob < 75:\n            continue\n        \n        edge = model_prob - implied_prob\n        if edge < 2:\n            continue\n        \n        if ev < -5:\n            continue\n        \n        candidates.append(market)\n    \n    candidates.sort(key=lambda x: (\n        -x.get(\"model_probability\", 0),\n        -x.get(\"expected_value\", 0)\n    ))\n    \n    return candidates\n\ndef stage2_deep_prune(candidates: List[Dict[str, Any]], limit: int = 12) -> List[Dict[str, Any]]:\n    scored_candidates = []\n    \n    for market in candidates:\n        selection = market.get(\"selection\", \"\")\n        sport = market.get(\"sport\", \"\")\n        home_team = market.get(\"home_team\", \"\")\n        away_team = market.get(\"away_team\", \"\")\n        odds = market.get(\"decimal_odds\", 1.15)\n        \n        opponent = away_team if selection == home_team else home_team\n        opp_odds = 1 / (1 - (1 / odds)) if odds > 1 and odds < 2 else 3.0\n        \n        fav_stats = get_team_stats(selection, sport, odds=odds, is_favorite=True)\n        opp_stats = get_team_stats(opponent, sport, odds=opp_odds, is_favorite=False) if opponent else {}\n        \n        rivalry_info = check_rivalry(home_team, away_team, sport)\n        \n        composite_score = calculate_composite_score(market, fav_stats, opp_stats, rivalry_info)\n        \n        rationale = generate_rationale(market, fav_stats, opp_stats, rivalry_info)\n        \n        enhanced_market = market.copy()\n        enhanced_market[\"composite_score\"] = composite_score\n        enhanced_market[\"rationale\"] = rationale\n        enhanced_market[\"rivalry_flag\"] = rivalry_info.get(\"is_rivalry\", False)\n        enhanced_market[\"rivalry_name\"] = rivalry_info.get(\"name\")\n        enhanced_market[\"favorite_stats\"] = {\n            \"win_rate\": fav_stats.get(\"win_rate\"),\n            \"last_10\": fav_stats.get(\"last_10_record\"),\n            \"point_diff\": fav_stats.get(\"point_differential\"),\n            \"consistency\": fav_stats.get(\"consistency_score\"),\n        }\n        enhanced_market[\"opponent_stats\"] = {\n            \"win_rate\": opp_stats.get(\"win_rate\") if opp_stats else None,\n            \"last_10\": opp_stats.get(\"last_10_record\") if opp_stats else None,\n            \"point_diff\": opp_stats.get(\"point_differential\") if opp_stats else None,\n        }\n        \n        scored_candidates.append(enhanced_market)\n    \n    scored_candidates.sort(key=lambda x: -x[\"composite_score\"])\n    \n    final_legs = []\n    used_events = set()\n    \n    for candidate in scored_candidates:\n        event_id = candidate.get(\"event_id\", \"\")\n        selection = candidate.get(\"selection\", \"\")\n        unique_key = f\"{event_id}_{selection}\"\n        \n        if unique_key not in used_events:\n            final_legs.append(candidate)\n            used_events.add(unique_key)\n        \n        if len(final_legs) >= limit:\n            break\n    \n    return final_legs\n\ndef get_recommended_legs_for_week(limit: int = None) -> List[Dict[str, Any]]:\n    if limit is None:\n        limit = SETTINGS.get(\"recommended_legs_count\", 12)\n    \n    min_odds = SETTINGS.get(\"min_odds_filter\", 1.05)\n    max_odds = SETTINGS.get(\"max_odds_filter\", 1.25)\n    \n    all_markets = get_all_analyzed_markets()\n    \n    stage1_candidates = stage1_numerical_filter(all_markets, min_odds, max_odds)\n    stage1_candidates = deduplicate_bets(stage1_candidates)\n    print(f\"Stage 1 filter: {len(all_markets)} markets -> {len(stage1_candidates)} candidates (after dedup)\")\n    \n    if len(stage1_candidates) < limit:\n        relaxed_candidates = []\n        for market in all_markets:\n            odds = market.get(\"decimal_odds\", 0)\n            if min_odds <= odds <= max_odds:\n                relaxed_candidates.append(market)\n        stage1_candidates = relaxed_candidates\n        print(f\"Relaxed filter applied: {len(stage1_candidates)} candidates\")\n    \n    final_legs = stage2_deep_prune(stage1_candidates, limit)\n    print(f\"Stage 2 prune: {len(stage1_candidates)} candidates -> {len(final_legs)} final legs\")\n    \n    return final_legs\n\ndef get_weekly_summary() -> Dict[str, Any]:\n    recommended = get_recommended_legs_for_week()\n    all_analyzed = get_all_analyzed_markets()\n    \n    sports_breakdown = {}\n    for leg in recommended:\n        sport = leg.get(\"sport\", \"unknown\")\n        if sport not in sports_breakdown:\n            sports_breakdown[sport] = 0\n        sports_breakdown[sport] += 1\n    \n    if recommended:\n        avg_odds = sum(l.get(\"decimal_odds\", 1) for l in recommended) / len(recommended)\n        avg_model_prob = sum(l.get(\"model_probability\", 0) for l in recommended) / len(recommended)\n        avg_ev = sum(l.get(\"expected_value\", 0) for l in recommended) / len(recommended)\n        avg_composite = sum(l.get(\"composite_score\", 50) for l in recommended) / len(recommended)\n    else:\n        avg_odds = 0\n        avg_model_prob = 0\n        avg_ev = 0\n        avg_composite = 0\n    \n    combined_odds = 1.0\n    for leg in recommended[:4]:\n        combined_odds *= leg.get(\"decimal_odds\", 1)\n    \n    rivalry_count = sum(1 for leg in recommended if leg.get(\"rivalry_flag\", False))\n    \n    return {\n        \"total_markets_analyzed\": len(all_analyzed),\n        \"recommended_legs_count\": len(recommended),\n        \"sports_breakdown\": sports_breakdown,\n        \"average_odds\": round(avg_odds, 2),\n        \"average_model_probability\": round(avg_model_prob, 2),\n        \"average_ev\": round(avg_ev, 2),\n        \"average_composite_score\": round(avg_composite, 2),\n        \"sample_4_leg_multi_odds\": round(combined_odds, 2),\n        \"rivalry_matchups_included\": rivalry_count,\n        \"recommended_legs\": recommended,\n    }\n","path":null,"size_bytes":16560,"size_tokens":null},"app/data_sources/odds_api.py":{"content":"from typing import List, Dict, Any, Optional\nimport requests\nfrom datetime import datetime, timedelta, timezone\nimport os\nimport time\n\nfrom app.config import (\n    API_KEYS, \n    ODDS_API_BASE_URL, \n    ODDS_API_SPORTS, \n    ODDS_API_REGIONS,\n    ODDS_API_MARKETS,\n    ODDS_API_PROPS_MARKETS,\n    MARKET_TYPE_MAPPING,\n    ALLOWED_MARKET_TYPES,\n    MAX_EVENT_DAYS_AHEAD,\n    EXCLUDE_TBA_STRINGS,\n    CONFIRMED_EVENT_STATUSES,\n    SUPPORTED_SPORTS\n)\n\nCACHE_TTL_SECONDS = 600\n_odds_cache: Dict[str, Dict[str, Any]] = {}\n_last_api_remaining: Optional[int] = None\n\ndef get_api_key() -> str:\n    return API_KEYS.get(\"odds_api\", \"\") or os.getenv(\"ODDS_API_KEY\", \"\")\n\ndef _get_cached(cache_key: str) -> Optional[List[Dict[str, Any]]]:\n    if cache_key in _odds_cache:\n        entry = _odds_cache[cache_key]\n        if time.time() - entry[\"timestamp\"] < CACHE_TTL_SECONDS:\n            print(f\"Cache HIT for {cache_key} (age: {int(time.time() - entry['timestamp'])}s)\")\n            return entry[\"data\"]\n        else:\n            del _odds_cache[cache_key]\n    return None\n\ndef _set_cached(cache_key: str, data: List[Dict[str, Any]]) -> None:\n    _odds_cache[cache_key] = {\n        \"timestamp\": time.time(),\n        \"data\": data\n    }\n    print(f\"Cached {len(data)} items for {cache_key}\")\n\ndef get_cache_stats() -> Dict[str, Any]:\n    now = time.time()\n    valid_entries = sum(1 for v in _odds_cache.values() if now - v[\"timestamp\"] < CACHE_TTL_SECONDS)\n    return {\n        \"total_entries\": len(_odds_cache),\n        \"valid_entries\": valid_entries,\n        \"ttl_seconds\": CACHE_TTL_SECONDS,\n        \"last_api_remaining\": _last_api_remaining,\n    }\n\ndef clear_cache() -> None:\n    global _odds_cache\n    _odds_cache = {}\n    print(\"Cache cleared\")\n\ndef is_confirmed_event(event: Dict[str, Any], max_days_ahead: int = None) -> bool:\n    if max_days_ahead is None:\n        max_days_ahead = MAX_EVENT_DAYS_AHEAD\n    \n    event_status = event.get(\"status\", event.get(\"event_status\", \"\")).lower()\n    if event_status and event_status not in [s.lower() for s in CONFIRMED_EVENT_STATUSES]:\n        return False\n    \n    commence_time = event.get(\"commence_time\", \"\")\n    if not commence_time:\n        return False\n    \n    try:\n        if isinstance(commence_time, str):\n            event_time = datetime.fromisoformat(commence_time.replace(\"Z\", \"+00:00\"))\n        else:\n            event_time = commence_time\n        \n        now = datetime.now(timezone.utc)\n        max_date = now + timedelta(days=max_days_ahead)\n        \n        if event_time < now or event_time > max_date:\n            return False\n    except Exception as e:\n        print(f\"Error parsing event time: {e}\")\n        return False\n    \n    home_team = event.get(\"home_team\", \"\").lower()\n    away_team = event.get(\"away_team\", \"\").lower()\n    \n    for keyword in EXCLUDE_TBA_STRINGS:\n        if keyword.lower() in home_team or keyword.lower() in away_team:\n            return False\n    \n    if not home_team or not away_team:\n        return False\n    \n    if home_team == away_team:\n        return False\n    \n    return True\n\ndef get_available_sports() -> List[Dict[str, Any]]:\n    api_key = get_api_key()\n    if not api_key:\n        return []\n    \n    try:\n        response = requests.get(\n            f\"{ODDS_API_BASE_URL}/sports\",\n            params={\"apiKey\": api_key}\n        )\n        if response.status_code == 200:\n            return response.json()\n        return []\n    except Exception as e:\n        print(f\"Error fetching sports: {e}\")\n        return []\n\ndef get_upcoming_odds(sport: str, regions: str = None, markets: str = None, include_props: bool = False) -> List[Dict[str, Any]]:\n    global _last_api_remaining\n    \n    cache_key = f\"odds_{sport.lower()}_{include_props}\"\n    cached = _get_cached(cache_key)\n    if cached is not None:\n        return cached\n    \n    api_key = get_api_key()\n    if not api_key:\n        print(f\"ERROR: No API key set. Set THE_ODDS_API_KEY environment variable.\")\n        return []\n    \n    sport_key = ODDS_API_SPORTS.get(sport.lower())\n    if not sport_key:\n        print(f\"ERROR: Unknown sport '{sport}'. Supported: {list(ODDS_API_SPORTS.keys())}\")\n        return []\n    \n    all_markets = []\n    \n    try:\n        response = requests.get(\n            f\"{ODDS_API_BASE_URL}/sports/{sport_key}/odds\",\n            params={\n                \"apiKey\": api_key,\n                \"regions\": regions or ODDS_API_REGIONS,\n                \"markets\": markets or ODDS_API_MARKETS,\n                \"oddsFormat\": \"decimal\"\n            }\n        )\n        \n        if response.status_code == 200:\n            remaining = response.headers.get(\"x-requests-remaining\", \"unknown\")\n            print(f\"Odds API requests remaining: {remaining}\")\n            try:\n                _last_api_remaining = int(remaining)\n            except:\n                pass\n            \n            events = response.json()\n            confirmed_events = [e for e in events if is_confirmed_event(e)]\n            print(f\"{sport.upper()}: {len(events)} total events, {len(confirmed_events)} confirmed within {MAX_EVENT_DAYS_AHEAD} days\")\n            \n            all_markets.extend(parse_odds_response(confirmed_events, sport))\n        else:\n            print(f\"Odds API error: {response.status_code} - {response.text}\")\n            return []\n    except Exception as e:\n        print(f\"Error fetching odds for {sport}: {e}\")\n        return []\n    \n    if include_props and sport.lower() in ODDS_API_PROPS_MARKETS:\n        props_markets = get_player_props(sport)\n        all_markets.extend(props_markets)\n    \n    _set_cached(cache_key, all_markets)\n    return all_markets\n\ndef get_player_props(sport: str, regions: str = None) -> List[Dict[str, Any]]:\n    global _last_api_remaining\n    \n    cache_key = f\"props_{sport.lower()}\"\n    cached = _get_cached(cache_key)\n    if cached is not None:\n        return cached\n    \n    api_key = get_api_key()\n    if not api_key:\n        return []\n    \n    sport_key = ODDS_API_SPORTS.get(sport.lower())\n    if not sport_key:\n        return []\n    \n    props_market_string = ODDS_API_PROPS_MARKETS.get(sport.lower(), \"\")\n    if not props_market_string:\n        return []\n    \n    all_props = []\n    \n    try:\n        response = requests.get(\n            f\"{ODDS_API_BASE_URL}/sports/{sport_key}/events\",\n            params={\"apiKey\": api_key}\n        )\n        \n        if response.status_code != 200:\n            print(f\"Error fetching events for props: {response.status_code}\")\n            return []\n        \n        events = response.json()\n        confirmed_events = [e for e in events if is_confirmed_event(e)]\n        \n        remaining = response.headers.get(\"x-requests-remaining\", \"unknown\")\n        print(f\"Odds API requests remaining: {remaining}\")\n        \n        for event in confirmed_events[:5]:\n            event_id = event.get(\"id\", \"\")\n            if not event_id:\n                continue\n            \n            try:\n                props_response = requests.get(\n                    f\"{ODDS_API_BASE_URL}/sports/{sport_key}/events/{event_id}/odds\",\n                    params={\n                        \"apiKey\": api_key,\n                        \"regions\": regions or ODDS_API_REGIONS,\n                        \"markets\": props_market_string,\n                        \"oddsFormat\": \"decimal\"\n                    }\n                )\n                \n                if props_response.status_code == 200:\n                    remaining = props_response.headers.get(\"x-requests-remaining\", \"unknown\")\n                    print(f\"Odds API requests remaining: {remaining}\")\n                    \n                    props_data = props_response.json()\n                    parsed_props = parse_props_response(props_data, sport, event)\n                    all_props.extend(parsed_props)\n            except Exception as e:\n                print(f\"Error fetching props for event {event_id}: {e}\")\n                continue\n                \n    except Exception as e:\n        print(f\"Error fetching player props for {sport}: {e}\")\n    \n    if all_props:\n        _set_cached(cache_key, all_props)\n    return all_props\n\ndef parse_props_response(data: Dict, sport: str, event_info: Dict) -> List[Dict[str, Any]]:\n    markets = []\n    sport_upper = sport.upper()\n    allowed_types = ALLOWED_MARKET_TYPES.get(sport_upper, [])\n    \n    event_id = data.get(\"id\", event_info.get(\"id\", \"\"))\n    home_team = data.get(\"home_team\", event_info.get(\"home_team\", \"\"))\n    away_team = data.get(\"away_team\", event_info.get(\"away_team\", \"\"))\n    commence_time = data.get(\"commence_time\", event_info.get(\"commence_time\", \"\"))\n    \n    for bookmaker in data.get(\"bookmakers\", []):\n        bookmaker_name = bookmaker.get(\"key\", \"\")\n        \n        for market in bookmaker.get(\"markets\", []):\n            market_key = market.get(\"key\", \"\")\n            mapped_market_type = MARKET_TYPE_MAPPING.get(market_key, market_key)\n            \n            if allowed_types and mapped_market_type not in allowed_types:\n                continue\n            \n            for outcome in market.get(\"outcomes\", []):\n                player_name = outcome.get(\"description\", \"\")\n                side = outcome.get(\"name\", \"\").lower()\n                point = outcome.get(\"point\")\n                decimal_odds = outcome.get(\"price\", 0)\n                \n                if decimal_odds > 0:\n                    if point is not None and side in [\"over\", \"under\"]:\n                        prop_type = market_key.replace(\"player_\", \"\").replace(\"fighter_\", \"\")\n                        selection_name = f\"{player_name} {side} {point} {prop_type}\"\n                    elif player_name:\n                        selection_name = f\"{player_name} {side}\" if side else player_name\n                    else:\n                        selection_name = side\n                    \n                    markets.append({\n                        \"event_id\": event_id,\n                        \"sport\": sport_upper,\n                        \"event\": f\"{home_team} vs {away_team}\",\n                        \"home_team\": home_team,\n                        \"away_team\": away_team,\n                        \"commence_time\": commence_time,\n                        \"market_type\": mapped_market_type,\n                        \"selection_name\": selection_name,\n                        \"line\": point,\n                        \"side\": side if side in [\"over\", \"under\"] else None,\n                        \"decimal_odds\": decimal_odds,\n                        \"bookmaker\": bookmaker_name,\n                        \"is_prop\": True,\n                        \"prop_player\": player_name,\n                    })\n    \n    return markets\n\ndef parse_odds_response(data: List[Dict], sport: str) -> List[Dict[str, Any]]:\n    markets = []\n    sport_upper = sport.upper()\n    allowed_types = ALLOWED_MARKET_TYPES.get(sport_upper, [])\n    \n    for event in data:\n        event_id = event.get(\"id\", \"\")\n        home_team = event.get(\"home_team\", \"\")\n        away_team = event.get(\"away_team\", \"\")\n        commence_time = event.get(\"commence_time\", \"\")\n        \n        for bookmaker in event.get(\"bookmakers\", []):\n            bookmaker_name = bookmaker.get(\"key\", \"\")\n            \n            for market in bookmaker.get(\"markets\", []):\n                market_key = market.get(\"key\", \"\")\n                mapped_market_type = MARKET_TYPE_MAPPING.get(market_key, market_key)\n                \n                if allowed_types and mapped_market_type not in allowed_types:\n                    continue\n                \n                for outcome in market.get(\"outcomes\", []):\n                    selection_name = outcome.get(\"name\", \"\")\n                    decimal_odds = outcome.get(\"price\", 0)\n                    point = outcome.get(\"point\")\n                    \n                    if decimal_odds > 0:\n                        markets.append({\n                            \"event_id\": event_id,\n                            \"sport\": sport_upper,\n                            \"event\": f\"{home_team} vs {away_team}\",\n                            \"home_team\": home_team,\n                            \"away_team\": away_team,\n                            \"commence_time\": commence_time,\n                            \"market_type\": mapped_market_type,\n                            \"selection_name\": selection_name,\n                            \"line\": point,\n                            \"side\": None,\n                            \"decimal_odds\": decimal_odds,\n                            \"bookmaker\": bookmaker_name,\n                            \"is_prop\": False,\n                        })\n    \n    return markets\n\ndef get_confirmed_upcoming_events_for_week(max_days_ahead: int = None) -> List[Dict[str, Any]]:\n    if max_days_ahead is None:\n        max_days_ahead = MAX_EVENT_DAYS_AHEAD\n    \n    all_events = []\n    api_key = get_api_key()\n    \n    if not api_key:\n        print(f\"ERROR: No API key set. Set THE_ODDS_API_KEY environment variable.\")\n        return []\n    \n    for sport in SUPPORTED_SPORTS:\n        sport_key = ODDS_API_SPORTS.get(sport.lower())\n        if not sport_key:\n            continue\n        \n        try:\n            response = requests.get(\n                f\"{ODDS_API_BASE_URL}/sports/{sport_key}/events\",\n                params={\"apiKey\": api_key}\n            )\n            \n            if response.status_code == 200:\n                events = response.json()\n                confirmed = [e for e in events if is_confirmed_event(e, max_days_ahead)]\n                \n                for event in confirmed:\n                    event[\"sport\"] = sport\n                \n                all_events.extend(confirmed)\n                print(f\"{sport.upper()}: {len(confirmed)} confirmed events in next {max_days_ahead} days\")\n        except Exception as e:\n            print(f\"Error fetching events for {sport}: {e}\")\n            continue\n    \n    return all_events\n\ndef get_upcoming_markets_for_week(include_props: bool = True) -> List[Dict[str, Any]]:\n    all_markets = []\n    \n    for sport in SUPPORTED_SPORTS:\n        try:\n            should_include_props = include_props and sport.lower() in ODDS_API_PROPS_MARKETS\n            sport_markets = get_upcoming_odds(sport, include_props=should_include_props)\n            all_markets.extend(sport_markets)\n        except Exception as e:\n            print(f\"Error fetching {sport} markets: {e}\")\n            continue\n    \n    return all_markets\n\ndef get_best_odds_per_selection(markets: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n    best_odds = {}\n    \n    for market in markets:\n        key = f\"{market['event_id']}_{market['selection_name']}\"\n        \n        if key not in best_odds or market['decimal_odds'] > best_odds[key]['decimal_odds']:\n            best_odds[key] = market\n    \n    return list(best_odds.values())\n\ndef get_odds_for_sport(sport: str) -> List[Dict[str, Any]]:\n    return get_upcoming_odds(sport, include_props=sport.lower() in ODDS_API_PROPS_MARKETS)\n","path":null,"size_bytes":14942,"size_tokens":null},"app/ui/script.js":{"content":"document.addEventListener('DOMContentLoaded', function() {\n    const sportFilter = document.getElementById('sportFilter');\n    const refreshBtn = document.getElementById('refreshBtn');\n    const betsContainer = document.getElementById('betsContainer');\n    const legsContainer = document.getElementById('legsContainer');\n    const lastUpdated = document.getElementById('lastUpdated');\n\n    loadWeeklySummary();\n    loadRecommendedLegs();\n\n    sportFilter.addEventListener('change', filterLegs);\n    refreshBtn.addEventListener('click', function() {\n        loadWeeklySummary();\n        loadRecommendedLegs();\n    });\n\n    let allLegs = [];\n\n    function filterLegs() {\n        const sport = sportFilter.value.toLowerCase();\n        if (!sport) {\n            renderLegs(allLegs);\n        } else {\n            renderLegs(allLegs.filter(leg => leg.sport.toLowerCase() === sport));\n        }\n    }\n\n    async function loadWeeklySummary() {\n        try {\n            const response = await fetch('/weekly-summary');\n            const data = await response.json();\n            \n            if (data.success) {\n                document.getElementById('marketsAnalyzed').textContent = data.total_markets_analyzed || '-';\n                document.getElementById('recommendedCount').textContent = data.recommended_legs_count || '-';\n                document.getElementById('avgProbability').textContent = data.average_model_probability ? `${data.average_model_probability}%` : '-';\n                document.getElementById('avgEV').textContent = data.average_ev ? `${data.average_ev > 0 ? '+' : ''}${data.average_ev}%` : '-';\n                \n                if (data.last_updated) {\n                    lastUpdated.textContent = `Last updated: ${new Date(data.last_updated).toLocaleString()}`;\n                }\n            }\n        } catch (error) {\n            console.error('Error loading summary:', error);\n        }\n    }\n\n    async function loadRecommendedLegs() {\n        legsContainer.innerHTML = '<p class=\"loading\">Loading recommended legs...</p>';\n        \n        try {\n            const response = await fetch('/recommended-legs?limit=20');\n            const data = await response.json();\n            \n            if (data.success && data.recommended_legs && data.recommended_legs.length > 0) {\n                allLegs = data.recommended_legs;\n                renderLegs(allLegs);\n            } else {\n                legsContainer.innerHTML = '<p class=\"loading\">No recommended legs found in the 1.05-1.25 odds range.</p>';\n            }\n        } catch (error) {\n            legsContainer.innerHTML = '<p class=\"error\">Error loading recommended legs. Please try again.</p>';\n            console.error('Error:', error);\n        }\n    }\n\n\n    function renderLegs(legs) {\n        legsContainer.innerHTML = `\n            <div class=\"legs-cards-container\">\n                ${legs.map((leg, index) => `\n                    <div class=\"leg-card ${leg.rivalry_flag ? 'rivalry-warning' : ''}\" data-index=\"${index}\">\n                        <div class=\"leg-card-header\">\n                            <div class=\"leg-header-left\">\n                                <span class=\"leg-number\">#${index + 1}</span>\n                                <span class=\"sport-badge\">${leg.sport.toUpperCase()}</span>\n                                ${leg.rivalry_flag ? '<span class=\"rivalry-badge\">Rivalry</span>' : ''}\n                            </div>\n                            <div class=\"leg-header-right\">\n                                <span class=\"confidence-badge ${(leg.confidence || 'medium').toLowerCase()}\">${leg.confidence || 'MEDIUM'}</span>\n                                <span class=\"composite-score\">Score: ${leg.composite_score?.toFixed(1) || '-'}</span>\n                            </div>\n                        </div>\n                        <div class=\"leg-card-body\">\n                            <div class=\"leg-event\">${leg.event || '-'}</div>\n                            <div class=\"leg-selection\">${leg.selection}</div>\n                            <div class=\"leg-stats\">\n                                <div class=\"stat-item\">\n                                    <span class=\"stat-label\">Odds</span>\n                                    <span class=\"stat-value odds\">$${leg.decimal_odds?.toFixed(2) || '-'}</span>\n                                </div>\n                                <div class=\"stat-item\">\n                                    <span class=\"stat-label\">Model %</span>\n                                    <span class=\"stat-value\">${leg.model_probability?.toFixed(1) || '-'}%</span>\n                                </div>\n                                <div class=\"stat-item\">\n                                    <span class=\"stat-label\">Implied %</span>\n                                    <span class=\"stat-value\">${leg.implied_probability?.toFixed(1) || '-'}%</span>\n                                </div>\n                                <div class=\"stat-item\">\n                                    <span class=\"stat-label\">EV</span>\n                                    <span class=\"stat-value ${leg.expected_value > 0 ? 'positive' : 'negative'}\">\n                                        ${leg.expected_value > 0 ? '+' : ''}${leg.expected_value?.toFixed(1) || '-'}%\n                                    </span>\n                                </div>\n                            </div>\n                            ${leg.favorite_stats ? `\n                                <div class=\"team-stats\">\n                                    <span class=\"stats-label\">Form:</span>\n                                    <span class=\"stats-value\">Last 10: ${leg.favorite_stats.last_10 || 'N/A'}</span>\n                                    <span class=\"stats-value\">Diff: ${leg.favorite_stats.point_diff > 0 ? '+' : ''}${leg.favorite_stats.point_diff?.toFixed(1) || 'N/A'}</span>\n                                </div>\n                            ` : ''}\n                        </div>\n                        ${leg.rationale ? `\n                            <div class=\"leg-rationale\">\n                                <div class=\"rationale-header\" onclick=\"this.parentElement.classList.toggle('expanded')\">\n                                    <span>Why this pick?</span>\n                                    <span class=\"expand-icon\">+</span>\n                                </div>\n                                <div class=\"rationale-content\">\n                                    <p>${leg.rationale}</p>\n                                </div>\n                            </div>\n                        ` : ''}\n                    </div>\n                `).join('')}\n            </div>\n            <div class=\"legs-footer\">\n                <p>These are high-confidence legs suitable for combining into a multi bet targeting ~$2.00 odds</p>\n                <p class=\"tip\">Tip: Select 3-4 legs from different sports to diversify your multi</p>\n            </div>\n        `;\n    }\n\n});\n\nfunction toggleRationale(btn) {\n    const popup = btn.nextElementSibling;\n    const allPopups = document.querySelectorAll('.rationale-popup');\n    allPopups.forEach(p => {\n        if (p !== popup) p.classList.remove('visible');\n    });\n    popup.classList.toggle('visible');\n}\n","path":null,"size_bytes":7271,"size_tokens":null},"app/config.py":{"content":"import os\n\nAPI_KEYS = {\n    \"odds_api\": os.getenv(\"THE_ODDS_API_KEY\", \"\") or os.getenv(\"ODDS_API_KEY\", \"\"),\n}\n\nSETTINGS = {\n    \"min_ev_threshold\": 0.02,\n    \"min_confidence_threshold\": 0.70,\n    \"target_multi_odds\": 2.0,\n    \"max_legs_in_multi\": 4,\n    \"min_odds_filter\": 1.05,\n    \"max_odds_filter\": 1.25,\n    \"recommended_legs_count\": 20,\n    \"stage1_min_model_prob\": 75,\n    \"stage1_min_edge\": 2,\n    \"stage1_candidate_limit\": 60,\n    \"stage2_rivalry_penalty\": 8,\n    \"stage2_consistency_bonus\": 4,\n}\n\nSUPPORTED_SPORTS = [\"nba\", \"nfl\"]\n\nODDS_API_SPORTS = {\n    \"nba\": \"basketball_nba\",\n    \"nfl\": \"americanfootball_nfl\",\n}\n\nODDS_API_BASE_URL = \"https://api.the-odds-api.com/v4\"\nODDS_API_REGIONS = \"au\"\nODDS_API_MARKETS = \"h2h\"\n\nODDS_API_PROPS_MARKETS = {\n    \"nba\": \"player_points,player_rebounds,player_assists,player_points_rebounds_assists,player_threes,player_blocks,player_steals,player_double_double,alternate_player_points,alternate_player_rebounds,alternate_player_assists,alternate_player_threes\",\n    \"nfl\": \"player_pass_tds,player_pass_yds,player_rush_yds,player_reception_yds,player_receptions,player_anytime_td,player_pass_completions,player_pass_attempts,player_rush_attempts,player_first_td,alternate_player_pass_yds,alternate_player_rush_yds,alternate_player_reception_yds\",\n}\n\nMARKET_TYPE_MAPPING = {\n    \"h2h\": \"moneyline\",\n    \"h2h_lay\": \"moneyline_lay\",\n    \"spreads\": \"spread\",\n    \"totals\": \"totals\",\n    \"player_points\": \"player_points_over_under\",\n    \"player_rebounds\": \"player_rebounds_over_under\",\n    \"player_assists\": \"player_assists_over_under\",\n    \"player_points_rebounds_assists\": \"player_pra_over_under\",\n    \"player_threes\": \"player_threes_over_under\",\n    \"player_blocks\": \"player_blocks_over_under\",\n    \"player_steals\": \"player_steals_over_under\",\n    \"player_double_double\": \"player_double_double\",\n    \"player_pass_tds\": \"player_pass_tds_over_under\",\n    \"player_pass_yds\": \"player_pass_yards_over_under\",\n    \"player_rush_yds\": \"player_rush_yards_over_under\",\n    \"player_reception_yds\": \"player_receiving_yards_over_under\",\n    \"player_receptions\": \"player_receptions_over_under\",\n    \"player_anytime_td\": \"player_anytime_touchdown\",\n    \"player_pass_completions\": \"player_pass_completions_over_under\",\n    \"player_pass_attempts\": \"player_pass_attempts_over_under\",\n    \"player_rush_attempts\": \"player_rush_attempts_over_under\",\n    \"player_first_td\": \"player_first_touchdown\",\n    \"alternate_player_points\": \"alternate_player_points\",\n    \"alternate_player_rebounds\": \"alternate_player_rebounds\",\n    \"alternate_player_assists\": \"alternate_player_assists\",\n    \"alternate_player_threes\": \"alternate_player_threes\",\n    \"alternate_player_pass_yds\": \"alternate_player_pass_yards\",\n    \"alternate_player_rush_yds\": \"alternate_player_rush_yards\",\n    \"alternate_player_reception_yds\": \"alternate_player_receiving_yards\",\n}\n\nALLOWED_MARKET_TYPES = {\n    \"NBA\": [\n        \"moneyline\",\n        \"player_points_over_under\",\n        \"player_assists_over_under\",\n        \"player_rebounds_over_under\",\n        \"player_threes_over_under\",\n        \"player_blocks_over_under\",\n        \"player_steals_over_under\",\n        \"player_pra_over_under\",\n        \"player_double_double\",\n        \"alternate_player_points\",\n        \"alternate_player_rebounds\",\n        \"alternate_player_assists\",\n        \"alternate_player_threes\",\n    ],\n    \"NFL\": [\n        \"moneyline\",\n        \"spread\",\n        \"totals\",\n        \"player_pass_tds_over_under\",\n        \"player_pass_yards_over_under\",\n        \"player_rush_yards_over_under\",\n        \"player_receiving_yards_over_under\",\n        \"player_receptions_over_under\",\n        \"player_anytime_touchdown\",\n        \"player_pass_completions_over_under\",\n        \"player_pass_attempts_over_under\",\n        \"player_rush_attempts_over_under\",\n        \"player_first_touchdown\",\n        \"alternate_player_pass_yards\",\n        \"alternate_player_rush_yards\",\n        \"alternate_player_receiving_yards\",\n    ],\n}\n\nCONFIRMED_EVENT_STATUSES = [\"scheduled\", \"pre_match\", \"open\"]\nMAX_EVENT_DAYS_AHEAD = 7\nEXCLUDE_TBA_STRINGS = [\"TBA\", \"To be announced\", \"tba\", \"to be announced\", \"TBD\", \"To be determined\"]\n\nMODEL_ARTIFACTS_PATH = \"model_artifacts\"\n","path":null,"size_bytes":4198,"size_tokens":null},"app/ui/styles.css":{"content":"* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;\n    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);\n    min-height: 100vh;\n    color: #e0e0e0;\n}\n\n.container {\n    max-width: 1400px;\n    margin: 0 auto;\n    padding: 20px;\n}\n\nheader {\n    text-align: center;\n    padding: 30px 0;\n    border-bottom: 1px solid #3a3a5c;\n    margin-bottom: 30px;\n}\n\nheader h1 {\n    color: #00d4ff;\n    font-size: 2.5rem;\n    margin-bottom: 10px;\n}\n\n.subtitle {\n    color: #a0a0b0;\n    font-size: 1.1rem;\n    margin-bottom: 5px;\n}\n\n.version {\n    color: #00ff88;\n    font-size: 0.9rem;\n}\n\n.summary-section {\n    margin-bottom: 30px;\n}\n\n.summary-card {\n    display: flex;\n    justify-content: space-around;\n    flex-wrap: wrap;\n    gap: 20px;\n    background: rgba(255, 255, 255, 0.05);\n    border-radius: 15px;\n    padding: 25px;\n    border: 1px solid #3a3a5c;\n}\n\n.summary-item {\n    text-align: center;\n    min-width: 150px;\n}\n\n.summary-label {\n    display: block;\n    color: #a0a0b0;\n    font-size: 0.85rem;\n    margin-bottom: 8px;\n}\n\n.summary-value {\n    font-size: 1.8rem;\n    font-weight: 700;\n    color: #00d4ff;\n}\n\n.filters {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n    margin-bottom: 30px;\n    padding: 20px;\n    background: rgba(255, 255, 255, 0.05);\n    border-radius: 10px;\n    flex-wrap: wrap;\n}\n\n.filters label {\n    font-weight: 500;\n}\n\n.filters select {\n    padding: 10px 15px;\n    border-radius: 8px;\n    border: 1px solid #3a3a5c;\n    background: #1a1a2e;\n    color: #e0e0e0;\n    font-size: 1rem;\n    cursor: pointer;\n}\n\n.btn {\n    padding: 10px 20px;\n    background: #00d4ff;\n    color: #1a1a2e;\n    border: none;\n    border-radius: 8px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: all 0.3s ease;\n}\n\n.btn:hover {\n    background: #00b8e6;\n    transform: translateY(-2px);\n}\n\n.btn-secondary {\n    background: transparent;\n    color: #00d4ff;\n    border: 1px solid #00d4ff;\n    text-decoration: none;\n}\n\n.btn-secondary:hover {\n    background: rgba(0, 212, 255, 0.2);\n}\n\n.back-link {\n    display: inline-block;\n    margin-top: 15px;\n    color: #00d4ff;\n    text-decoration: none;\n    font-size: 0.95rem;\n}\n\n.back-link:hover {\n    text-decoration: underline;\n}\n\n.stats-bar {\n    display: flex;\n    gap: 30px;\n    padding: 15px 20px;\n    background: rgba(0, 212, 255, 0.1);\n    border-radius: 10px;\n    margin-bottom: 15px;\n    font-weight: 600;\n}\n\n.stats-bar span {\n    color: #00d4ff;\n}\n\n.market-cell {\n    color: #a0a0b0;\n    font-size: 0.85rem;\n}\n\n.last-updated {\n    color: #a0a0b0;\n    font-size: 0.85rem;\n    margin-left: auto;\n}\n\nsection {\n    margin-bottom: 40px;\n}\n\nsection h2 {\n    color: #00d4ff;\n    margin-bottom: 10px;\n    font-size: 1.5rem;\n}\n\n.section-desc {\n    color: #a0a0b0;\n    margin-bottom: 20px;\n    font-size: 0.95rem;\n}\n\n.legs-table-container {\n    overflow-x: auto;\n    background: linear-gradient(135deg, #2a2a4e 0%, #1a1a3e 100%);\n    border-radius: 15px;\n    border: 1px solid #3a3a5c;\n}\n\n.legs-table {\n    width: 100%;\n    border-collapse: collapse;\n}\n\n.legs-table th {\n    background: rgba(0, 212, 255, 0.1);\n    padding: 15px 12px;\n    text-align: left;\n    font-weight: 600;\n    color: #00d4ff;\n    border-bottom: 1px solid #3a3a5c;\n}\n\n.legs-table td {\n    padding: 15px 12px;\n    border-bottom: 1px solid rgba(58, 58, 92, 0.5);\n}\n\n.leg-row:hover {\n    background: rgba(255, 255, 255, 0.05);\n}\n\n.sport-badge {\n    padding: 4px 10px;\n    background: #00d4ff;\n    color: #1a1a2e;\n    border-radius: 20px;\n    font-size: 0.75rem;\n    font-weight: 600;\n}\n\n.selection-name {\n    font-weight: 600;\n    color: #fff;\n}\n\n.odds-value {\n    color: #00ff88;\n    font-weight: 600;\n}\n\n.model-prob {\n    color: #00d4ff;\n    font-weight: 600;\n}\n\n.ev-value.positive {\n    color: #00ff88;\n}\n\n.ev-value.negative {\n    color: #ff4444;\n}\n\n.confidence-badge {\n    padding: 4px 12px;\n    border-radius: 20px;\n    font-size: 0.8rem;\n    font-weight: 600;\n}\n\n.confidence-badge.high {\n    background: rgba(0, 255, 136, 0.2);\n    color: #00ff88;\n}\n\n.confidence-badge.medium {\n    background: rgba(255, 170, 0, 0.2);\n    color: #ffaa00;\n}\n\n.confidence-badge.low {\n    background: rgba(255, 102, 0, 0.2);\n    color: #ff6600;\n}\n\n.confidence-badge.none {\n    background: rgba(255, 68, 68, 0.2);\n    color: #ff4444;\n}\n\n.legs-footer {\n    padding: 20px;\n    text-align: center;\n    border-top: 1px solid #3a3a5c;\n}\n\n.legs-footer p {\n    color: #a0a0b0;\n    margin-bottom: 5px;\n}\n\n.legs-footer .tip {\n    color: #00ff88;\n    font-size: 0.9rem;\n}\n\n.bet-card {\n    background: linear-gradient(135deg, #2a2a4e 0%, #1a1a3e 100%);\n    border-radius: 12px;\n    padding: 20px;\n    margin-bottom: 15px;\n    border: 1px solid #3a3a5c;\n    transition: transform 0.2s ease;\n}\n\n.bet-card:hover {\n    transform: translateX(5px);\n    border-color: #00d4ff;\n}\n\n.bet-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: flex-start;\n    margin-bottom: 10px;\n}\n\n.bet-selection {\n    font-size: 1.2rem;\n    font-weight: 600;\n    color: #fff;\n}\n\n.bet-sport {\n    padding: 5px 12px;\n    background: #00d4ff;\n    color: #1a1a2e;\n    border-radius: 20px;\n    font-size: 0.8rem;\n    font-weight: 600;\n}\n\n.bet-event {\n    color: #a0a0b0;\n    font-size: 0.9rem;\n    margin-bottom: 15px;\n}\n\n.bet-details {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));\n    gap: 15px;\n}\n\n.detail-item {\n    text-align: center;\n    padding: 10px;\n    background: rgba(255, 255, 255, 0.05);\n    border-radius: 8px;\n}\n\n.detail-label {\n    font-size: 0.75rem;\n    color: #a0a0b0;\n    margin-bottom: 5px;\n}\n\n.detail-value {\n    font-size: 1rem;\n    font-weight: 600;\n}\n\n.detail-value.positive {\n    color: #00ff88;\n}\n\n.detail-value.negative {\n    color: #ff4444;\n}\n\n.confidence-high, .detail-value.confidence-high {\n    color: #00ff88;\n}\n\n.confidence-medium, .detail-value.confidence-medium {\n    color: #ffaa00;\n}\n\n.confidence-low, .detail-value.confidence-low {\n    color: #ff6600;\n}\n\n.confidence-none, .detail-value.confidence-none {\n    color: #ff4444;\n}\n\n.loading {\n    text-align: center;\n    padding: 40px;\n    color: #a0a0b0;\n}\n\n.error {\n    text-align: center;\n    padding: 40px;\n    color: #ff4444;\n    background: rgba(255, 68, 68, 0.1);\n    border-radius: 10px;\n}\n\n.legs-cards-container {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));\n    gap: 20px;\n    padding: 10px 0;\n}\n\n.leg-card {\n    background: linear-gradient(135deg, #2a2a4e 0%, #1a1a3e 100%);\n    border-radius: 15px;\n    border: 1px solid #3a3a5c;\n    overflow: hidden;\n    transition: all 0.3s ease;\n}\n\n.leg-card:hover {\n    transform: translateY(-5px);\n    border-color: #00d4ff;\n    box-shadow: 0 10px 30px rgba(0, 212, 255, 0.1);\n}\n\n.leg-card.rivalry-warning {\n    border-color: #ffaa00;\n}\n\n.leg-card-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 15px;\n    background: rgba(0, 212, 255, 0.05);\n    border-bottom: 1px solid #3a3a5c;\n}\n\n.leg-header-left {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n}\n\n.leg-number {\n    font-size: 0.85rem;\n    font-weight: 700;\n    color: #a0a0b0;\n}\n\n.rivalry-badge {\n    padding: 3px 8px;\n    background: rgba(255, 170, 0, 0.2);\n    color: #ffaa00;\n    border-radius: 12px;\n    font-size: 0.7rem;\n    font-weight: 600;\n}\n\n.leg-header-right {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n}\n\n.composite-score {\n    font-size: 0.8rem;\n    color: #a0a0b0;\n}\n\n.leg-card-body {\n    padding: 15px;\n}\n\n.leg-event {\n    color: #a0a0b0;\n    font-size: 0.9rem;\n    margin-bottom: 5px;\n}\n\n.leg-selection {\n    font-size: 1.2rem;\n    font-weight: 600;\n    color: #fff;\n    margin-bottom: 15px;\n}\n\n.leg-stats {\n    display: grid;\n    grid-template-columns: repeat(4, 1fr);\n    gap: 10px;\n    margin-bottom: 10px;\n}\n\n.stat-item {\n    text-align: center;\n    padding: 8px;\n    background: rgba(255, 255, 255, 0.05);\n    border-radius: 8px;\n}\n\n.stat-label {\n    display: block;\n    font-size: 0.7rem;\n    color: #a0a0b0;\n    margin-bottom: 4px;\n}\n\n.stat-value {\n    font-size: 0.95rem;\n    font-weight: 600;\n    color: #fff;\n}\n\n.stat-value.odds {\n    color: #00ff88;\n}\n\n.stat-value.positive {\n    color: #00ff88;\n}\n\n.stat-value.negative {\n    color: #ff4444;\n}\n\n.team-stats {\n    display: flex;\n    gap: 10px;\n    padding: 10px;\n    background: rgba(0, 212, 255, 0.05);\n    border-radius: 8px;\n    font-size: 0.85rem;\n    flex-wrap: wrap;\n}\n\n.stats-label {\n    color: #a0a0b0;\n}\n\n.stats-value {\n    color: #00d4ff;\n}\n\n.leg-rationale {\n    border-top: 1px solid #3a3a5c;\n}\n\n.rationale-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 12px 15px;\n    cursor: pointer;\n    background: rgba(0, 212, 255, 0.05);\n    transition: background 0.2s ease;\n}\n\n.rationale-header:hover {\n    background: rgba(0, 212, 255, 0.1);\n}\n\n.rationale-header span:first-child {\n    font-size: 0.9rem;\n    color: #00d4ff;\n    font-weight: 500;\n}\n\n.expand-icon {\n    color: #00d4ff;\n    font-weight: 700;\n    font-size: 1.2rem;\n    transition: transform 0.3s ease;\n}\n\n.leg-rationale.expanded .expand-icon {\n    transform: rotate(45deg);\n}\n\n.rationale-content {\n    max-height: 0;\n    overflow: hidden;\n    transition: max-height 0.3s ease, padding 0.3s ease;\n}\n\n.leg-rationale.expanded .rationale-content {\n    max-height: 300px;\n    padding: 15px;\n}\n\n.rationale-content p {\n    color: #e0e0e0;\n    font-size: 0.9rem;\n    line-height: 1.6;\n}\n\n.table-container {\n    overflow-x: auto;\n    background: linear-gradient(135deg, #2a2a4e 0%, #1a1a3e 100%);\n    border-radius: 15px;\n    border: 1px solid #3a3a5c;\n}\n\n.bets-table {\n    width: 100%;\n    border-collapse: collapse;\n    min-width: 900px;\n}\n\n.bets-table th {\n    background: rgba(0, 212, 255, 0.1);\n    padding: 15px 10px;\n    text-align: left;\n    font-weight: 600;\n    color: #00d4ff;\n    border-bottom: 2px solid #3a3a5c;\n    white-space: nowrap;\n}\n\n.bets-table td {\n    padding: 12px 10px;\n    border-bottom: 1px solid rgba(58, 58, 92, 0.5);\n    vertical-align: middle;\n}\n\n.bet-row:hover {\n    background: rgba(0, 212, 255, 0.05);\n}\n\n.bet-row.high-confidence {\n    background: rgba(0, 255, 136, 0.03);\n}\n\n.sport-badge.small {\n    padding: 3px 8px;\n    font-size: 0.7rem;\n}\n\n.confidence-badge.small {\n    padding: 3px 8px;\n    font-size: 0.7rem;\n}\n\n.event-cell {\n    max-width: 200px;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    color: #a0a0b0;\n}\n\n.selection-cell {\n    color: #fff;\n}\n\n.odds-cell {\n    color: #00ff88;\n    font-weight: 600;\n}\n\n.positive {\n    color: #00ff88;\n}\n\n.negative {\n    color: #ff4444;\n}\n\n.rationale-cell {\n    position: relative;\n}\n\n.rationale-btn {\n    padding: 5px 12px;\n    background: rgba(0, 212, 255, 0.2);\n    color: #00d4ff;\n    border: 1px solid #00d4ff;\n    border-radius: 5px;\n    cursor: pointer;\n    font-size: 0.8rem;\n    transition: all 0.2s ease;\n}\n\n.rationale-btn:hover {\n    background: rgba(0, 212, 255, 0.4);\n}\n\n.rationale-popup {\n    display: none;\n    position: absolute;\n    right: 0;\n    top: 100%;\n    width: 400px;\n    max-width: 90vw;\n    padding: 15px;\n    background: #1a1a2e;\n    border: 1px solid #00d4ff;\n    border-radius: 10px;\n    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);\n    z-index: 1000;\n    font-size: 0.85rem;\n    line-height: 1.5;\n    color: #e0e0e0;\n}\n\n.rationale-popup.visible {\n    display: block;\n}\n\n.disclaimer {\n    margin-top: 40px;\n    padding: 20px;\n    background: rgba(255, 170, 0, 0.1);\n    border: 1px solid rgba(255, 170, 0, 0.3);\n    border-radius: 10px;\n    text-align: center;\n}\n\n.disclaimer p {\n    color: #a0a0b0;\n    font-size: 0.85rem;\n    margin-bottom: 10px;\n}\n\n.disclaimer .timestamp {\n    color: #00d4ff;\n    font-size: 0.8rem;\n}\n\n@media (max-width: 768px) {\n    .filters {\n        flex-direction: column;\n        align-items: stretch;\n    }\n    \n    .last-updated {\n        margin-left: 0;\n        text-align: center;\n    }\n    \n    .bet-details {\n        grid-template-columns: repeat(2, 1fr);\n    }\n    \n    header h1 {\n        font-size: 1.8rem;\n    }\n    \n    .summary-card {\n        flex-direction: column;\n    }\n    \n    .legs-table {\n        font-size: 0.85rem;\n    }\n    \n    .legs-table th, .legs-table td {\n        padding: 10px 8px;\n    }\n    \n    .legs-cards-container {\n        grid-template-columns: 1fr;\n    }\n    \n    .leg-stats {\n        grid-template-columns: repeat(2, 1fr);\n    }\n    \n    .leg-card-header {\n        flex-direction: column;\n        gap: 10px;\n        align-items: flex-start;\n    }\n    \n    .leg-header-right {\n        width: 100%;\n        justify-content: space-between;\n    }\n}\n","path":null,"size_bytes":12729,"size_tokens":null},"fetch_scheduled.py":{"content":"#!/usr/bin/env python3\nimport sys\nsys.path.insert(0, '.')\n\nfrom app.scheduled_fetch import fetch_and_store_all_odds, is_fetch_day\nfrom datetime import datetime\n\nif __name__ == \"__main__\":\n    print(f\"Scheduled fetch triggered at {datetime.now().isoformat()}\")\n    print(f\"Today: {datetime.now().strftime('%A')}\")\n    print(f\"Is fetch day (Mon/Thu): {is_fetch_day()}\")\n    \n    if is_fetch_day() or \"--force\" in sys.argv:\n        result = fetch_and_store_all_odds()\n        print(f\"Fetch completed successfully\")\n        print(f\"Total markets: {sum(s.get('h2h_count', 0) + s.get('props_count', 0) for s in result.get('sports', {}).values())}\")\n    else:\n        print(\"Not a fetch day. Use --force to fetch anyway.\")\n","path":null,"size_bytes":716,"size_tokens":null},"app/scheduled_fetch.py":{"content":"import os\nimport json\nfrom datetime import datetime\nfrom app.data_sources.odds_api import get_upcoming_odds, get_player_props, clear_cache\nfrom app.config import SUPPORTED_SPORTS\n\nDATA_FILE = \"cached_odds_data.json\"\n\ndef is_fetch_day():\n    today = datetime.now().weekday()\n    return today in [0, 3]  # Monday=0, Thursday=3\n\ndef fetch_and_store_all_odds():\n    print(f\"Scheduled fetch started at {datetime.now().isoformat()}\")\n    \n    clear_cache()\n    \n    all_data = {\n        \"fetch_time\": datetime.now().isoformat(),\n        \"sports\": {}\n    }\n    \n    for sport in SUPPORTED_SPORTS:\n        print(f\"Fetching {sport}...\")\n        \n        h2h_markets = get_upcoming_odds(sport)\n        props_markets = get_player_props(sport)\n        \n        all_data[\"sports\"][sport] = {\n            \"h2h\": h2h_markets,\n            \"props\": props_markets,\n            \"h2h_count\": len(h2h_markets),\n            \"props_count\": len(props_markets)\n        }\n        \n        print(f\"  {sport}: {len(h2h_markets)} h2h, {len(props_markets)} props\")\n    \n    with open(DATA_FILE, \"w\") as f:\n        json.dump(all_data, f, indent=2)\n    \n    print(f\"Data saved to {DATA_FILE}\")\n    print(f\"Scheduled fetch completed at {datetime.now().isoformat()}\")\n    \n    return all_data\n\ndef load_stored_data():\n    if os.path.exists(DATA_FILE):\n        with open(DATA_FILE, \"r\") as f:\n            return json.load(f)\n    return None\n\ndef get_stored_odds_for_sport(sport: str):\n    data = load_stored_data()\n    if data and sport.lower() in data.get(\"sports\", {}):\n        sport_data = data[\"sports\"][sport.lower()]\n        return sport_data.get(\"h2h\", []) + sport_data.get(\"props\", [])\n    return []\n\nif __name__ == \"__main__\":\n    if is_fetch_day():\n        fetch_and_store_all_odds()\n    else:\n        print(f\"Today is not a fetch day (Mon/Thu). Current day: {datetime.now().strftime('%A')}\")\n        print(\"Run with --force to fetch anyway\")\n        import sys\n        if \"--force\" in sys.argv:\n            fetch_and_store_all_odds()\n","path":null,"size_bytes":2010,"size_tokens":null},"app/data_sources/nba_stats.py":{"content":"from typing import Dict, Any, Optional, List\nfrom datetime import datetime, timedelta\nimport time\nimport json\n\ntry:\n    from nba_api.stats.endpoints import playergamelog, leagueleaders, teamgamelog, commonteamroster\n    from nba_api.stats.static import players, teams\n    from nba_api.live.nba.endpoints import scoreboard\n    NBA_API_AVAILABLE = True\nexcept ImportError:\n    NBA_API_AVAILABLE = False\n    print(\"nba_api not available - NBA stats will use fallback\")\n\n_stats_cache: Dict[str, Any] = {}\n_cache_ttl = 3600\n\ndef _get_current_season() -> str:\n    now = datetime.now()\n    if now.month >= 10:\n        return f\"{now.year}-{str(now.year + 1)[2:]}\"\n    else:\n        return f\"{now.year - 1}-{str(now.year)[2:]}\"\n\ndef _safe_api_call(func, *args, **kwargs):\n    try:\n        time.sleep(0.6)\n        if 'timeout' not in kwargs:\n            kwargs['timeout'] = 10\n        return func(*args, **kwargs)\n    except Exception as e:\n        print(f\"NBA API call failed: {e}\")\n        return None\n\ndef get_player_id(player_name: str) -> Optional[int]:\n    if not NBA_API_AVAILABLE:\n        return None\n    \n    cache_key = f\"player_id_{player_name.lower()}\"\n    if cache_key in _stats_cache:\n        return _stats_cache[cache_key]\n    \n    try:\n        all_players = players.get_players()\n        name_lower = player_name.lower()\n        \n        for p in all_players:\n            if p['full_name'].lower() == name_lower:\n                _stats_cache[cache_key] = p['id']\n                return p['id']\n        \n        for p in all_players:\n            if name_lower in p['full_name'].lower():\n                _stats_cache[cache_key] = p['id']\n                return p['id']\n        \n        name_parts = name_lower.split()\n        if len(name_parts) >= 2:\n            for p in all_players:\n                player_parts = p['full_name'].lower().split()\n                if len(player_parts) >= 2:\n                    if name_parts[-1] == player_parts[-1]:\n                        _stats_cache[cache_key] = p['id']\n                        return p['id']\n    except Exception as e:\n        print(f\"Error finding player {player_name}: {e}\")\n    \n    return None\n\ndef get_team_id(team_name: str) -> Optional[int]:\n    if not NBA_API_AVAILABLE:\n        return None\n    \n    cache_key = f\"team_id_{team_name.lower()}\"\n    if cache_key in _stats_cache:\n        return _stats_cache[cache_key]\n    \n    try:\n        all_teams = teams.get_teams()\n        name_lower = team_name.lower()\n        \n        for t in all_teams:\n            if t['full_name'].lower() == name_lower:\n                _stats_cache[cache_key] = t['id']\n                return t['id']\n        \n        for t in all_teams:\n            if t['nickname'].lower() in name_lower or name_lower in t['full_name'].lower():\n                _stats_cache[cache_key] = t['id']\n                return t['id']\n    except Exception as e:\n        print(f\"Error finding team {team_name}: {e}\")\n    \n    return None\n\ndef get_player_season_stats(player_name: str, last_n_games: int = 10) -> Dict[str, Any]:\n    cache_key = f\"player_stats_{player_name.lower()}_{last_n_games}\"\n    now = datetime.now()\n    \n    if cache_key in _stats_cache:\n        cached = _stats_cache[cache_key]\n        if (now - cached['timestamp']).seconds < _cache_ttl:\n            return cached['data']\n    \n    if not NBA_API_AVAILABLE:\n        return {\"error\": \"NBA API not available\", \"source\": \"none\"}\n    \n    player_id = get_player_id(player_name)\n    if not player_id:\n        return {\"error\": f\"Player not found: {player_name}\", \"source\": \"none\"}\n    \n    try:\n        season = _get_current_season()\n        gamelog = _safe_api_call(\n            playergamelog.PlayerGameLog,\n            player_id=player_id,\n            season=season\n        )\n        \n        if not gamelog:\n            return {\"error\": \"Failed to fetch game log\", \"source\": \"none\"}\n        \n        df = gamelog.get_data_frames()[0]\n        \n        if df.empty:\n            return {\"error\": \"No games this season\", \"source\": \"none\"}\n        \n        recent_games = df.head(last_n_games)\n        \n        stats = {\n            \"player_name\": player_name,\n            \"player_id\": player_id,\n            \"games_played\": len(recent_games),\n            \"season\": season,\n            \"source\": \"nba_api\",\n            \"last_updated\": now.isoformat(),\n            \"averages\": {\n                \"points\": round(recent_games['PTS'].mean(), 1) if 'PTS' in recent_games else 0,\n                \"rebounds\": round(recent_games['REB'].mean(), 1) if 'REB' in recent_games else 0,\n                \"assists\": round(recent_games['AST'].mean(), 1) if 'AST' in recent_games else 0,\n                \"threes\": round(recent_games['FG3M'].mean(), 1) if 'FG3M' in recent_games else 0,\n                \"steals\": round(recent_games['STL'].mean(), 1) if 'STL' in recent_games else 0,\n                \"blocks\": round(recent_games['BLK'].mean(), 1) if 'BLK' in recent_games else 0,\n                \"minutes\": round(recent_games['MIN'].mean(), 1) if 'MIN' in recent_games else 0,\n            },\n            \"recent_games\": []\n        }\n        \n        for _, game in recent_games.iterrows():\n            stats[\"recent_games\"].append({\n                \"date\": str(game.get('GAME_DATE', '')),\n                \"matchup\": str(game.get('MATCHUP', '')),\n                \"points\": int(game.get('PTS', 0)),\n                \"rebounds\": int(game.get('REB', 0)),\n                \"assists\": int(game.get('AST', 0)),\n                \"threes\": int(game.get('FG3M', 0)),\n                \"minutes\": str(game.get('MIN', '0')),\n            })\n        \n        hit_rates = {}\n        for stat_key, col in [('points', 'PTS'), ('rebounds', 'REB'), ('assists', 'AST'), ('threes', 'FG3M')]:\n            if col in recent_games.columns:\n                values = recent_games[col].tolist()\n                avg = stats['averages'][stat_key]\n                thresholds = _get_stat_thresholds(stat_key, avg)\n                hit_rates[stat_key] = {}\n                for threshold in thresholds:\n                    hits = sum(1 for v in values if v >= threshold)\n                    hit_rates[stat_key][threshold] = round(hits / len(values), 3) if values else 0\n        \n        stats['hit_rates'] = hit_rates\n        \n        _stats_cache[cache_key] = {'data': stats, 'timestamp': now}\n        return stats\n        \n    except Exception as e:\n        print(f\"Error fetching player stats for {player_name}: {e}\")\n        return {\"error\": str(e), \"source\": \"none\"}\n\ndef _get_stat_thresholds(stat_type: str, avg: float) -> List[float]:\n    if stat_type == 'points':\n        base = [10, 15, 20, 25, 30, 35, 40]\n    elif stat_type == 'rebounds':\n        base = [5, 8, 10, 12, 15]\n    elif stat_type == 'assists':\n        base = [4, 6, 8, 10, 12]\n    elif stat_type == 'threes':\n        base = [2, 3, 4, 5, 6]\n    else:\n        base = [5, 10, 15]\n    \n    return [t for t in base if t <= avg * 1.5]\n\ndef get_team_stats_real(team_name: str, last_n_games: int = 10) -> Dict[str, Any]:\n    cache_key = f\"team_stats_{team_name.lower()}_{last_n_games}\"\n    now = datetime.now()\n    \n    if cache_key in _stats_cache:\n        cached = _stats_cache[cache_key]\n        if (now - cached['timestamp']).seconds < _cache_ttl:\n            return cached['data']\n    \n    if not NBA_API_AVAILABLE:\n        return {\"error\": \"NBA API not available\", \"source\": \"none\"}\n    \n    team_id = get_team_id(team_name)\n    if not team_id:\n        return {\"error\": f\"Team not found: {team_name}\", \"source\": \"none\"}\n    \n    try:\n        season = _get_current_season()\n        gamelog = _safe_api_call(\n            teamgamelog.TeamGameLog,\n            team_id=team_id,\n            season=season\n        )\n        \n        if not gamelog:\n            return {\"error\": \"Failed to fetch team game log\", \"source\": \"none\"}\n        \n        df = gamelog.get_data_frames()[0]\n        \n        if df.empty:\n            return {\"error\": \"No games this season\", \"source\": \"none\"}\n        \n        recent = df.head(last_n_games)\n        wins = len(recent[recent['WL'] == 'W'])\n        \n        stats = {\n            \"team_name\": team_name,\n            \"team_id\": team_id,\n            \"season\": season,\n            \"source\": \"nba_api\",\n            \"last_updated\": now.isoformat(),\n            \"games_played\": len(recent),\n            \"wins\": wins,\n            \"losses\": len(recent) - wins,\n            \"win_rate\": round(wins / len(recent), 3) if recent.size > 0 else 0.5,\n            \"ppg\": round(recent['PTS'].mean(), 1) if 'PTS' in recent else 0,\n            \"opponent_ppg\": round(recent['PTS'].mean() - recent['PLUS_MINUS'].mean(), 1) if 'PLUS_MINUS' in recent else 0,\n            \"avg_plus_minus\": round(recent['PLUS_MINUS'].mean(), 1) if 'PLUS_MINUS' in recent else 0,\n            \"last_10_record\": f\"{wins}-{len(recent) - wins}\",\n        }\n        \n        _stats_cache[cache_key] = {'data': stats, 'timestamp': now}\n        return stats\n        \n    except Exception as e:\n        print(f\"Error fetching team stats for {team_name}: {e}\")\n        return {\"error\": str(e), \"source\": \"none\"}\n\ndef get_player_prop_probability(player_name: str, prop_type: str, line: float) -> Dict[str, Any]:\n    stats = get_player_season_stats(player_name, last_n_games=15)\n    \n    if stats.get(\"error\"):\n        return {\n            \"player\": player_name,\n            \"prop_type\": prop_type,\n            \"line\": line,\n            \"over_probability\": 0.5,\n            \"confidence\": \"none\",\n            \"source\": \"no_data\",\n            \"error\": stats.get(\"error\")\n        }\n    \n    prop_mapping = {\n        'points': 'points',\n        'rebounds': 'rebounds',\n        'assists': 'assists',\n        'threes': 'threes',\n        '3pm': 'threes',\n        'steals': 'steals',\n        'blocks': 'blocks',\n    }\n    \n    stat_key = prop_mapping.get(prop_type.lower())\n    if not stat_key or stat_key not in stats.get('averages', {}):\n        return {\n            \"player\": player_name,\n            \"prop_type\": prop_type,\n            \"line\": line,\n            \"over_probability\": 0.5,\n            \"confidence\": \"none\",\n            \"source\": \"unknown_prop\"\n        }\n    \n    avg = stats['averages'][stat_key]\n    \n    if 'hit_rates' in stats and stat_key in stats['hit_rates']:\n        hit_rates = stats['hit_rates'][stat_key]\n        closest_threshold = min(hit_rates.keys(), key=lambda x: abs(x - line), default=None)\n        if closest_threshold is not None:\n            over_prob = hit_rates[closest_threshold]\n            if closest_threshold < line:\n                adjustment = (line - closest_threshold) / avg * 0.1 if avg > 0 else 0\n                over_prob = max(0.1, over_prob - adjustment)\n            elif closest_threshold > line:\n                adjustment = (closest_threshold - line) / avg * 0.1 if avg > 0 else 0\n                over_prob = min(0.9, over_prob + adjustment)\n        else:\n            over_prob = 0.5 + (avg - line) / (avg + 1) * 0.3\n    else:\n        over_prob = 0.5 + (avg - line) / (avg + 1) * 0.3\n    \n    over_prob = max(0.1, min(0.9, over_prob))\n    \n    games_played = stats.get('games_played', 0)\n    if games_played >= 10:\n        confidence = \"high\"\n    elif games_played >= 5:\n        confidence = \"medium\"\n    else:\n        confidence = \"low\"\n    \n    return {\n        \"player\": player_name,\n        \"prop_type\": prop_type,\n        \"line\": line,\n        \"season_avg\": avg,\n        \"over_probability\": round(over_prob, 3),\n        \"under_probability\": round(1 - over_prob, 3),\n        \"confidence\": confidence,\n        \"games_analyzed\": games_played,\n        \"source\": \"nba_api\",\n        \"recent_values\": [g.get(stat_key.replace('threes', 'threes'), g.get('points', 0)) for g in stats.get('recent_games', [])[:5]]\n    }\n\ndef clear_stats_cache():\n    global _stats_cache\n    _stats_cache = {}\n    return {\"status\": \"cleared\"}\n","path":null,"size_bytes":11836,"size_tokens":null},"app/data_sources/nfl_stats.py":{"content":"from typing import Dict, Any, Optional, List\nfrom datetime import datetime, timedelta\nimport json\nimport httpx\n\n_stats_cache: Dict[str, Any] = {}\n_cache_ttl = 3600\n\nESPN_BASE_URL = \"https://site.api.espn.com/apis/site/v2/sports/football/nfl\"\nESPN_CORE_URL = \"https://sports.core.api.espn.com/v2/sports/football/leagues/nfl\"\nESPN_WEB_URL = \"https://site.web.api.espn.com/apis/common/v3/sports/football/nfl\"\n\nNFL_TEAMS = {\n    \"arizona cardinals\": {\"id\": \"22\", \"abbrev\": \"ARI\"},\n    \"atlanta falcons\": {\"id\": \"1\", \"abbrev\": \"ATL\"},\n    \"baltimore ravens\": {\"id\": \"33\", \"abbrev\": \"BAL\"},\n    \"buffalo bills\": {\"id\": \"2\", \"abbrev\": \"BUF\"},\n    \"carolina panthers\": {\"id\": \"29\", \"abbrev\": \"CAR\"},\n    \"chicago bears\": {\"id\": \"3\", \"abbrev\": \"CHI\"},\n    \"cincinnati bengals\": {\"id\": \"4\", \"abbrev\": \"CIN\"},\n    \"cleveland browns\": {\"id\": \"5\", \"abbrev\": \"CLE\"},\n    \"dallas cowboys\": {\"id\": \"6\", \"abbrev\": \"DAL\"},\n    \"denver broncos\": {\"id\": \"7\", \"abbrev\": \"DEN\"},\n    \"detroit lions\": {\"id\": \"8\", \"abbrev\": \"DET\"},\n    \"green bay packers\": {\"id\": \"9\", \"abbrev\": \"GB\"},\n    \"houston texans\": {\"id\": \"34\", \"abbrev\": \"HOU\"},\n    \"indianapolis colts\": {\"id\": \"11\", \"abbrev\": \"IND\"},\n    \"jacksonville jaguars\": {\"id\": \"30\", \"abbrev\": \"JAX\"},\n    \"kansas city chiefs\": {\"id\": \"12\", \"abbrev\": \"KC\"},\n    \"las vegas raiders\": {\"id\": \"13\", \"abbrev\": \"LV\"},\n    \"los angeles chargers\": {\"id\": \"24\", \"abbrev\": \"LAC\"},\n    \"los angeles rams\": {\"id\": \"14\", \"abbrev\": \"LAR\"},\n    \"miami dolphins\": {\"id\": \"15\", \"abbrev\": \"MIA\"},\n    \"minnesota vikings\": {\"id\": \"16\", \"abbrev\": \"MIN\"},\n    \"new england patriots\": {\"id\": \"17\", \"abbrev\": \"NE\"},\n    \"new orleans saints\": {\"id\": \"18\", \"abbrev\": \"NO\"},\n    \"new york giants\": {\"id\": \"19\", \"abbrev\": \"NYG\"},\n    \"new york jets\": {\"id\": \"20\", \"abbrev\": \"NYJ\"},\n    \"philadelphia eagles\": {\"id\": \"21\", \"abbrev\": \"PHI\"},\n    \"pittsburgh steelers\": {\"id\": \"23\", \"abbrev\": \"PIT\"},\n    \"san francisco 49ers\": {\"id\": \"25\", \"abbrev\": \"SF\"},\n    \"seattle seahawks\": {\"id\": \"26\", \"abbrev\": \"SEA\"},\n    \"tampa bay buccaneers\": {\"id\": \"27\", \"abbrev\": \"TB\"},\n    \"tennessee titans\": {\"id\": \"10\", \"abbrev\": \"TEN\"},\n    \"washington commanders\": {\"id\": \"28\", \"abbrev\": \"WSH\"},\n}\n\nasync def _async_fetch(url: str, timeout: float = 10.0) -> Optional[Dict]:\n    try:\n        async with httpx.AsyncClient() as client:\n            response = await client.get(url, timeout=timeout)\n            if response.status_code == 200:\n                return response.json()\n    except Exception as e:\n        print(f\"ESPN API error for {url}: {e}\")\n    return None\n\ndef _sync_fetch(url: str, timeout: float = 10.0) -> Optional[Dict]:\n    try:\n        with httpx.Client() as client:\n            response = client.get(url, timeout=timeout)\n            if response.status_code == 200:\n                return response.json()\n    except Exception as e:\n        print(f\"ESPN API error for {url}: {e}\")\n    return None\n\ndef get_team_id(team_name: str) -> Optional[str]:\n    name_lower = team_name.lower()\n    \n    if name_lower in NFL_TEAMS:\n        return NFL_TEAMS[name_lower][\"id\"]\n    \n    for full_name, info in NFL_TEAMS.items():\n        if name_lower in full_name or full_name in name_lower:\n            return info[\"id\"]\n        parts = full_name.split()\n        if parts[-1] in name_lower:\n            return info[\"id\"]\n    \n    return None\n\ndef get_player_id_from_espn(player_name: str, team_id: Optional[str] = None) -> Optional[str]:\n    cache_key = f\"espn_player_id_{player_name.lower()}\"\n    if cache_key in _stats_cache:\n        return _stats_cache[cache_key]\n    \n    try:\n        url = f\"{ESPN_BASE_URL}/athletes\"\n        params = {\"limit\": 100}\n        \n        response = _sync_fetch(f\"{url}?limit=100\")\n        if response and 'athletes' in response:\n            name_lower = player_name.lower()\n            for athlete in response['athletes']:\n                if athlete.get('fullName', '').lower() == name_lower:\n                    _stats_cache[cache_key] = athlete['id']\n                    return athlete['id']\n                if name_lower in athlete.get('fullName', '').lower():\n                    _stats_cache[cache_key] = athlete['id']\n                    return athlete['id']\n    except Exception as e:\n        print(f\"Error finding ESPN player ID for {player_name}: {e}\")\n    \n    return None\n\nKNOWN_PLAYERS = {\n    \"patrick mahomes\": \"3139477\",\n    \"josh allen\": \"3918298\",\n    \"lamar jackson\": \"3916387\",\n    \"jalen hurts\": \"4040715\",\n    \"joe burrow\": \"3915511\",\n    \"dak prescott\": \"2577417\",\n    \"travis kelce\": \"15847\",\n    \"tyreek hill\": \"3116406\",\n    \"ceedee lamb\": \"4241389\",\n    \"ja'marr chase\": \"4362628\",\n    \"derrick henry\": \"3043078\",\n    \"saquon barkley\": \"3929630\",\n    \"christian mccaffrey\": \"3117251\",\n    \"nick chubb\": \"3128720\",\n    \"bijan robinson\": \"4426467\",\n    \"davante adams\": \"16800\",\n    \"justin jefferson\": \"4262921\",\n    \"amon-ra st. brown\": \"4374302\",\n    \"cooper kupp\": \"3046288\",\n}\n\ndef get_player_stats_espn(player_name: str, last_n_games: int = 10) -> Dict[str, Any]:\n    cache_key = f\"nfl_player_stats_{player_name.lower()}_{last_n_games}\"\n    now = datetime.now()\n    \n    if cache_key in _stats_cache:\n        cached = _stats_cache[cache_key]\n        if (now - cached.get('timestamp', datetime.min)).seconds < _cache_ttl:\n            return cached['data']\n    \n    name_lower = player_name.lower()\n    player_id = KNOWN_PLAYERS.get(name_lower)\n    \n    if not player_id:\n        player_id = get_player_id_from_espn(player_name)\n    \n    if not player_id:\n        return {\n            \"player_name\": player_name,\n            \"error\": \"Player not found in ESPN database\",\n            \"source\": \"none\"\n        }\n    \n    try:\n        overview_url = f\"{ESPN_WEB_URL}/athletes/{player_id}/overview\"\n        data = _sync_fetch(overview_url)\n        \n        if not data:\n            stats_url = f\"{ESPN_WEB_URL}/athletes/{player_id}/stats\"\n            data = _sync_fetch(stats_url)\n        \n        if not data:\n            return {\n                \"player_name\": player_name,\n                \"player_id\": player_id,\n                \"error\": \"Failed to fetch stats from ESPN\",\n                \"source\": \"none\"\n            }\n        \n        stats = parse_espn_player_stats(player_name, player_id, data)\n        \n        _stats_cache[cache_key] = {'data': stats, 'timestamp': now}\n        return stats\n        \n    except Exception as e:\n        print(f\"Error fetching ESPN stats for {player_name}: {e}\")\n        return {\n            \"player_name\": player_name,\n            \"player_id\": player_id,\n            \"error\": str(e),\n            \"source\": \"none\"\n        }\n\ndef parse_espn_player_stats(player_name: str, player_id: str, data: Dict) -> Dict[str, Any]:\n    stats = {\n        \"player_name\": player_name,\n        \"player_id\": player_id,\n        \"source\": \"espn_api\",\n        \"last_updated\": datetime.now().isoformat(),\n        \"position\": \"\",\n        \"averages\": {},\n        \"totals\": {},\n        \"season_stats\": {}\n    }\n    \n    try:\n        if 'athlete' in data:\n            athlete = data['athlete']\n            pos = athlete.get('position', {})\n            stats['position'] = pos.get('abbreviation', '') if isinstance(pos, dict) else ''\n            team = athlete.get('team', {})\n            stats['team'] = team.get('displayName', '') if isinstance(team, dict) else ''\n        \n        statistics = data.get('statistics', {})\n        if isinstance(statistics, dict):\n            names = statistics.get('names', [])\n            labels = statistics.get('labels', [])\n            splits = statistics.get('splits', [])\n            \n            for split in splits:\n                if isinstance(split, dict) and split.get('displayName') == 'Regular Season':\n                    split_stats = split.get('stats', [])\n                    for i, value in enumerate(split_stats):\n                        if i < len(names):\n                            name = names[i]\n                            try:\n                                clean_value = str(value).replace(',', '')\n                                stats['season_stats'][name] = float(clean_value) if clean_value and clean_value != '--' else 0\n                            except (ValueError, TypeError):\n                                stats['season_stats'][name] = 0\n            \n            games = 13\n            season = stats['season_stats']\n            \n            if 'passingYards' in season:\n                stats['averages']['pass_yards'] = round(season['passingYards'] / games, 1)\n            if 'passingTouchdowns' in season:\n                stats['averages']['pass_tds'] = round(season['passingTouchdowns'] / games, 2)\n            if 'rushingYards' in season:\n                stats['averages']['rush_yards'] = round(season['rushingYards'] / games, 1)\n            if 'receivingYards' in season:\n                stats['averages']['rec_yards'] = round(season['receivingYards'] / games, 1)\n            if 'receptions' in season:\n                stats['averages']['receptions'] = round(season['receptions'] / games, 1)\n            if 'receivingTouchdowns' in season:\n                stats['averages']['rec_tds'] = round(season['receivingTouchdowns'] / games, 2)\n            if 'completions' in season:\n                stats['averages']['completions'] = round(season['completions'] / games, 1)\n            \n            stats['totals'] = season.copy()\n            \n    except Exception as e:\n        print(f\"Error parsing ESPN stats: {e}\")\n        stats['parse_error'] = str(e)\n    \n    return stats\n\ndef get_team_stats_espn(team_name: str) -> Dict[str, Any]:\n    cache_key = f\"nfl_team_stats_{team_name.lower()}\"\n    now = datetime.now()\n    \n    if cache_key in _stats_cache:\n        cached = _stats_cache[cache_key]\n        if (now - cached.get('timestamp', datetime.min)).seconds < _cache_ttl:\n            return cached['data']\n    \n    team_id = get_team_id(team_name)\n    if not team_id:\n        return {\n            \"team_name\": team_name,\n            \"error\": \"Team not found\",\n            \"source\": \"none\"\n        }\n    \n    try:\n        team_url = f\"{ESPN_BASE_URL}/teams/{team_id}\"\n        data = _sync_fetch(team_url)\n        \n        if not data or 'team' not in data:\n            return {\n                \"team_name\": team_name,\n                \"team_id\": team_id,\n                \"error\": \"Failed to fetch team data\",\n                \"source\": \"none\"\n            }\n        \n        team_data = data['team']\n        record = team_data.get('record', {})\n        \n        stats = {\n            \"team_name\": team_name,\n            \"team_id\": team_id,\n            \"display_name\": team_data.get('displayName', team_name),\n            \"source\": \"espn_api\",\n            \"last_updated\": now.isoformat(),\n        }\n        \n        record_items = record.get('items', []) if isinstance(record, dict) else []\n        for item in record_items:\n            if isinstance(item, dict) and item.get('type') == 'total':\n                summary = item.get('summary', '0-0')\n                parts = summary.split('-')\n                if len(parts) >= 2:\n                    try:\n                        wins = int(parts[0])\n                        losses = int(parts[1])\n                        total = wins + losses\n                        stats['wins'] = wins\n                        stats['losses'] = losses\n                        stats['win_rate'] = round(wins / total, 3) if total > 0 else 0.5\n                        stats['record'] = summary\n                    except (ValueError, TypeError):\n                        pass\n                \n                item_stats = item.get('stats', [])\n                if isinstance(item_stats, list):\n                    for stat in item_stats:\n                        if isinstance(stat, dict):\n                            name = stat.get('name', '')\n                            value = stat.get('value', 0)\n                            if name == 'avgPointsFor':\n                                stats['ppg'] = round(value, 1)\n                            elif name == 'avgPointsAgainst':\n                                stats['defensive_rating'] = round(value, 1)\n                            elif name == 'pointDifferential':\n                                stats['point_diff'] = round(value, 1)\n        \n        _stats_cache[cache_key] = {'data': stats, 'timestamp': now}\n        return stats\n        \n    except Exception as e:\n        print(f\"Error fetching ESPN team stats for {team_name}: {e}\")\n        return {\n            \"team_name\": team_name,\n            \"team_id\": team_id,\n            \"error\": str(e),\n            \"source\": \"none\"\n        }\n\ndef get_nfl_leaders(stat_type: str = \"passing\", limit: int = 20) -> List[Dict[str, Any]]:\n    cache_key = f\"nfl_leaders_{stat_type}_{limit}\"\n    now = datetime.now()\n    \n    if cache_key in _stats_cache:\n        cached = _stats_cache[cache_key]\n        if (now - cached.get('timestamp', datetime.min)).seconds < _cache_ttl:\n            return cached['data']\n    \n    try:\n        url = f\"{ESPN_BASE_URL}/leaders\"\n        data = _sync_fetch(url)\n        \n        if not data or 'leaders' not in data:\n            return []\n        \n        leaders = []\n        for category in data.get('leaders', []):\n            if stat_type.lower() in category.get('name', '').lower():\n                for leader in category.get('leaders', [])[:limit]:\n                    athlete = leader.get('athlete', {})\n                    leaders.append({\n                        \"rank\": leader.get('rank', 0),\n                        \"player_name\": athlete.get('fullName', ''),\n                        \"player_id\": athlete.get('id', ''),\n                        \"team\": athlete.get('team', {}).get('abbreviation', ''),\n                        \"value\": leader.get('value', 0),\n                        \"stat\": category.get('name', stat_type)\n                    })\n        \n        _stats_cache[cache_key] = {'data': leaders, 'timestamp': now}\n        return leaders\n        \n    except Exception as e:\n        print(f\"Error fetching NFL leaders: {e}\")\n        return []\n\ndef get_player_prop_probability_nfl(player_name: str, prop_type: str, line: float) -> Dict[str, Any]:\n    stats = get_player_stats_espn(player_name)\n    \n    if stats.get(\"error\"):\n        return {\n            \"player\": player_name,\n            \"prop_type\": prop_type,\n            \"line\": line,\n            \"over_probability\": 0.5,\n            \"confidence\": \"none\",\n            \"source\": \"no_data\",\n            \"error\": stats.get(\"error\")\n        }\n    \n    prop_mapping = {\n        'pass_yards': 'pass_yards',\n        'passing_yards': 'pass_yards',\n        'pass_tds': 'pass_tds',\n        'passing_touchdowns': 'pass_tds',\n        'rush_yards': 'rush_yards',\n        'rushing_yards': 'rush_yards',\n        'rec_yards': 'rec_yards',\n        'receiving_yards': 'rec_yards',\n        'receptions': 'receptions',\n    }\n    \n    stat_key = prop_mapping.get(prop_type.lower())\n    averages = stats.get('averages', {})\n    \n    if not stat_key or stat_key not in averages:\n        return {\n            \"player\": player_name,\n            \"prop_type\": prop_type,\n            \"line\": line,\n            \"over_probability\": 0.5,\n            \"confidence\": \"none\",\n            \"source\": \"unknown_prop\"\n        }\n    \n    avg = averages[stat_key]\n    \n    diff = avg - line\n    std_estimate = avg * 0.25\n    if std_estimate > 0:\n        z_score = diff / std_estimate\n        over_prob = 0.5 + (z_score * 0.15)\n    else:\n        over_prob = 0.5\n    \n    over_prob = max(0.15, min(0.85, over_prob))\n    \n    return {\n        \"player\": player_name,\n        \"prop_type\": prop_type,\n        \"line\": line,\n        \"season_avg\": avg,\n        \"over_probability\": round(over_prob, 3),\n        \"under_probability\": round(1 - over_prob, 3),\n        \"confidence\": \"medium\",\n        \"source\": \"espn_api\",\n    }\n\ndef clear_stats_cache():\n    global _stats_cache\n    _stats_cache = {}\n    return {\"status\": \"cleared\"}\n","path":null,"size_bytes":15948,"size_tokens":null}},"version":2}